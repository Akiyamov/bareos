#!/bin/sh

. scripts/functions

#
# Run a big test with backup of millions of files then run 100 incremental
# modifying 10% each time
#
# Can use following env variables
# ACCURATE=yes
# BASEJOB=yes
# NB_CONCURENT=4
# NB_FULL=25
# NB_INCR=25
# NB_FILES=750000
#
# TODO: this test is not enabled.
#

TestName="speed-test"
JobName=speed

${rscripts}/cleanup

# Directory to backup.
BackupDirectory="${tmp}/data"
mkdir -p $cwd/files
echo "$BackupDirectory" >${tmp}/file-list

${rscripts}/copy-test-confs
sed 's/Max Run Time/#Max Run Time/' $conf/bareos-dir.conf > $tmp/1
sed 's/SpoolData/#SpoolData/' $tmp/1 > $conf/bareos-dir.conf

change_jobname CompressedTest $JobName
if [ a$ACCURATE != a ]; then
  sed 's/Name = "speed"/Name = "speed"; accurate=yes/' $conf/bareos-dir.conf > $tmp/1
  mv $tmp/1 $conf/bareos-dir.conf
fi

if [ a$BASEJOB != a ]; then
  sed 's/Name = "speed"/Name = "speed"; accurate=yes;basejob=speed/' $conf/bareos-dir.conf > $tmp/1
  mv $tmp/1 $conf/bareos-dir.conf
  basejob="level=base"
fi

NB_CONCURENT=${NB_CONCURENT:-1}
NB_FULL=${NB_FULL:-20}
NB_INCR=${NB_INCR:-25}
NB_FILES=${NB_FILES:-100000}

start_test

echo "Creating $NB_FILES files"
perl -Mscripts::functions -e "create_many_files('$BackupDirectory', $NB_FILES);"

cat <<END_OF_DATA >${tmp}/bconcmds
@$out /dev/null
messages
@$out ${tmp}/log1.out
label storage=File volume=TestVolume001
run job=$JobName $basejob yes
wait
messages
quit
END_OF_DATA

run_bareos
check_for_zombie_jobs storage=File

cat <<END_OF_DATA >${tmp}/bconcmds
@$out /dev/null
messages
@$out ${tmp}/log1.out
END_OF_DATA

for j in $(seq 1 $NB_CONCURENT); do
    cat <<EOF >>${tmp}/bconcmds
@sleep 5
run job=$JobName level=Full yes
EOF
done

cat <<EOF >>${tmp}/bconcmds
wait
messages
quit
EOF

# insert X million files into File table
for i in $(seq 0 $NB_FULL); do
    run_bconsole
done

# Now, run many incremental
sed 's/Full/Incremental/' ${tmp}/bconcmds > $tmp/1
mv $tmp/1 ${tmp}/bconcmds

for i in $(seq 0 $NB_INCR); do
    perl -Mscripts::functions -e "update_some_files('$BackupDirectory/'.chr($i+65));"
    run_bconsole
done

cat <<END_OF_DATA >${tmp}/bconcmds
@$out /dev/null
messages
@#
@# now do a restore
@#
@$out ${tmp}/log2.out
time
restore where=${tmp}/bareos-restores storage=File select all done yes
time
wait
time
status storage=File
messages
quit
END_OF_DATA

run_bconsole
check_for_zombie_jobs storage=File
stop_bareos

check_two_logs
#rm -rf ${tmp}/files

find ${tmp}/bareos-restores | wc -l | tee $tmp/bareos-restore-list
rm -rf ${tmp}/bareos-restores

# check the time needed to compute restore list
if [ x$db_password != x ]; then
   p="-P $db_password"
fi

# Disabled, as it is not sure, what bbatch does.
# Also, this test is the only one, using it.
# Without this test, there is no need to compile it at all.
#(time $bin/bbatch -r 1 -n $db_name -u $db_user $p -w $tmp) >> $working/log 2>&1

cp $working/log files/log-${DBTYPE}-$(date +%F_%H-%M).log
cp $tmp/log2.out files/log2-${DBTYPE}-$(date +%F_%H-%M).log

end_test
