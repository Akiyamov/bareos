<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Bareos Developer Guide</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="pandoc.css" type="text/css" />
</head>
<body>
<div id="footer">
<hr>
&copy; 2015 <a href="http://www.bareos.org/">Bareos Project</a>
<hr>
</div>
<div id="header">
<h1 class="title">Bareos Developer Guide</h1>
</div>
<div id="TOC">
<ul>
<li><a href="#contributions">Contributions</a></li>
<li><a href="#patches">Patches</a></li>
<li><a href="#copyrights">Copyrights</a></li>
<li><a href="#copyright-assignment-fiduciary-license-agreement">Copyright Assignment – Fiduciary License Agreement</a></li>
<li><a href="#the-development-cycle">The Development Cycle</a></li>
<li><a href="#bacula-code-submissions-and-projects">Bacula Code Submissions and Projects</a></li>
<li><a href="#patches-for-released-versions">Patches for Released Versions</a></li>
<li><a href="#developing-bacula">Developing Bacula</a><ul>
<li><a href="#debugging">Debugging</a></li>
<li><a href="#using-a-debugger">Using a Debugger</a></li>
<li><a href="#memory-leaks">Memory Leaks</a></li>
<li><a href="#special-files">Special Files</a></li>
<li><a href="#when-implementing-incomplete-code">When Implementing Incomplete Code</a></li>
<li><a href="#bacula-source-file-structure">Bacula Source File Structure</a></li>
<li><a href="#header-files">Header Files</a></li>
<li><a href="#programming-standards">Programming Standards</a></li>
<li><a href="#do-not-use">Do Not Use</a></li>
<li><a href="#avoid-if-possible">Avoid if Possible</a></li>
<li><a href="#do-use-whenever-possible">Do Use Whenever Possible</a></li>
<li><a href="#indenting-standards">Indenting Standards</a></li>
<li><a href="#tabbing">Tabbing</a></li>
<li><a href="#donts">Don’ts</a></li>
<li><a href="#message-classes">Message Classes</a></li>
<li><a href="#debug-messages">Debug Messages</a></li>
<li><a href="#error-messages">Error Messages</a></li>
<li><a href="#job-messages">Job Messages</a></li>
<li><a href="#queued-job-messages">Queued Job Messages</a></li>
<li><a href="#memory-messages">Memory Messages</a></li>
<li><a href="#bugs-database">Bugs Database</a></li>
</ul></li>
<li><a href="#bacula-fd-plugin-api">Bacula FD Plugin API</a><ul>
<li><a href="#normal-vs-command-vs-options-plugins">Normal vs Command vs Options Plugins</a></li>
<li><a href="#loading-plugins">Loading Plugins</a></li>
<li><a href="#loadplugin">loadPlugin</a></li>
<li><a href="#plugin-entry-points">Plugin Entry Points</a><ul>
<li><a href="#newpluginbpcontext-ctx">newPlugin(bpContext *ctx)</a></li>
<li><a href="#freepluginbpcontext-ctx">freePlugin(bpContext *ctx)</a></li>
<li><a href="#getpluginvaluebpcontext-ctx-pvariable-var-void-value">getPluginValue(bpContext *ctx, pVariable var, void *value)</a></li>
<li><a href="#setpluginvaluebpcontext-ctx-pvariable-var-void-value">setPluginValue(bpContext *ctx, pVariable var, void *value)</a></li>
<li><a href="#handleplugineventbpcontext-ctx-bevent-event-void-value">handlePluginEvent(bpContext *ctx, bEvent *event, void *value)</a></li>
<li><a href="#startbackupfilebpcontext-ctx-struct-save_pkt-sp">startBackupFile(bpContext *ctx, struct save_pkt *sp)</a></li>
<li><a href="#endbackupfilebpcontext-ctx">endBackupFile(bpContext *ctx)</a></li>
<li><a href="#startrestorefilebpcontext-ctx-const-char-cmd">startRestoreFile(bpContext *ctx, const char *cmd)</a></li>
<li><a href="#createfilebpcontext-ctx-struct-restore_pkt-rp">createFile(bpContext *ctx, struct restore_pkt *rp)</a></li>
<li><a href="#setfileattributesbpcontext-ctx-struct-restore_pkt-rp">setFileAttributes(bpContext *ctx, struct restore_pkt *rp)</a></li>
<li><a href="#endrestorefilebpcontext-ctx">endRestoreFile(bpContext *ctx)</a></li>
<li><a href="#pluginiobpcontext-ctx-struct-io_pkt-io">pluginIO(bpContext *ctx, struct io_pkt *io)</a></li>
<li><a href="#bool-checkfilebpcontext-ctx-char-fname">bool checkFile(bpContext *ctx, char *fname)</a></li>
</ul></li>
<li><a href="#bacula-plugin-entrypoints">Bacula Plugin Entrypoints</a><ul>
<li><a href="#brc-registerbaculaeventsbpcontext-ctx">bRC registerBaculaEvents(bpContext *ctx, …)</a></li>
<li><a href="#brc-getbaculavaluebpcontext-ctx-bvariable-var-void-value">bRC getBaculaValue(bpContext *ctx, bVariable var, void *value)</a></li>
<li><a href="#brc-setbaculavaluebpcontext-ctx-bvariable-var-void-value">bRC setBaculaValue(bpContext *ctx, bVariable var, void *value)</a></li>
<li><a href="#brc-jobmessagebpcontext-ctx-const-char-file-int-line-int-type-utime_t-mtime-const-char-fmt">bRC JobMessage(bpContext *ctx, const char *file, int line, int type, utime_t mtime, const char *fmt, …)</a></li>
<li><a href="#brc-debugmessagebpcontext-ctx-const-char-file-int-line-int-level-const-char-fmt">bRC DebugMessage(bpContext *ctx, const char *file, int line, int level, const char *fmt, …)</a></li>
<li><a href="#void-baculamallocbpcontext-ctx-const-char-file-int-line-size_t-size">void baculaMalloc(bpContext *ctx, const char *file, int line, size_t size)</a></li>
<li><a href="#void-baculafreebpcontext-ctx-const-char-file-int-line-void-mem">void baculaFree(bpContext *ctx, const char *file, int line, void *mem)</a></li>
</ul></li>
<li><a href="#building-bacula-plugins">Building Bacula Plugins</a></li>
<li><a href="#general">General</a></li>
<li><a href="#requirements-to-become-a-supported-platform">Requirements to become a Supported Platform</a></li>
<li><a href="#general-1">General</a></li>
<li><a href="#low-level-network-protocol">Low Level Network Protocol</a></li>
<li><a href="#general-daemon-protocol">General Daemon Protocol</a></li>
<li><a href="#the-protocol-used-between-the-director-and-the-storage-daemon">The Protocol Used Between the Director and the Storage Daemon</a></li>
<li><a href="#the-protocol-used-between-the-director-and-the-file-daemon">The Protocol Used Between the Director and the File Daemon</a></li>
<li><a href="#the-save-protocol-between-the-file-daemon-and-the-storage-daemon">The Save Protocol Between the File Daemon and the Storage Daemon</a><ul>
<li><a href="#command-and-control-information">Command and Control Information</a></li>
<li><a href="#data-information">Data Information</a></li>
</ul></li>
<li><a href="#commands-received-from-the-director-for-a-backup">Commands Received from the Director for a Backup</a></li>
<li><a href="#commands-received-from-the-director-for-a-restore">Commands Received from the Director for a Restore</a></li>
<li><a href="#sd-design-introduction">SD Design Introduction</a></li>
<li><a href="#sd-development-outline">SD Development Outline</a></li>
<li><a href="#sd-connections-and-sessions">SD Connections and Sessions</a><ul>
<li><a href="#sd-append-requests">SD Append Requests</a></li>
<li><a href="#sd-read-requests">SD Read Requests</a></li>
</ul></li>
<li><a href="#sd-data-structures">SD Data Structures</a></li>
<li><a href="#general-2">General</a><ul>
<li><a href="#filenames-and-maximum-filename-length">Filenames and Maximum Filename Length</a></li>
<li><a href="#installing-and-configuring-mysql">Installing and Configuring MySQL</a></li>
<li><a href="#installing-and-configuring-postgresql">Installing and Configuring PostgreSQL</a></li>
<li><a href="#installing-and-configuring-sqlite">Installing and Configuring SQLite</a></li>
<li><a href="#internal-bacula-catalog">Internal Bacula Catalog</a></li>
<li><a href="#database-table-design">Database Table Design</a></li>
</ul></li>
<li><a href="#sequence-of-creation-of-records-for-a-save-job">Sequence of Creation of Records for a Save Job</a></li>
<li><a href="#database-tables">Database Tables</a><ul>
<li><a href="#mysql-table-definition">MySQL Table Definition</a></li>
</ul></li>
<li><a href="#general-3">General</a></li>
<li><a href="#definitions">Definitions</a></li>
<li><a href="#storage-daemon-file-output-format">Storage Daemon File Output Format</a></li>
<li><a href="#overall-format">Overall Format</a></li>
<li><a href="#serialization">Serialization</a></li>
<li><a href="#block-header">Block Header</a></li>
<li><a href="#record-header">Record Header</a></li>
<li><a href="#version-bb02-block-header">Version BB02 Block Header</a></li>
<li><a href="#version-2-record-header">Version 2 Record Header</a></li>
<li><a href="#volume-label-format">Volume Label Format</a></li>
<li><a href="#session-label">Session Label</a></li>
<li><a href="#overall-storage-format">Overall Storage Format</a></li>
<li><a href="#unix-file-attributes">Unix File Attributes</a></li>
<li><a href="#porting-requirements">Porting Requirements</a></li>
<li><a href="#steps-to-take-for-porting">Steps to Take for Porting</a></li>
<li><a href="#general-4">General</a><ul>
<li><a href="#minimal-code-in-console-program">Minimal Code in Console Program</a></li>
<li><a href="#gui-interface-is-difficult">GUI Interface is Difficult</a></li>
</ul></li>
<li><a href="#sec:bvfs">Bvfs API</a><ul>
<li><a href="#general-notes">General notes</a></li>
<li><a href="#get-dependent-jobs-from-a-given-jobid">Get dependent jobs from a given JobId</a></li>
<li><a href="#generating-bvfs-cache">Generating Bvfs cache</a></li>
<li><a href="#get-all-versions-of-a-specific-file">Get all versions of a specific file</a></li>
<li><a href="#list-directories">List directories</a></li>
<li><a href="#list-files">List files</a></li>
<li><a href="#restore-set-of-files">Restore set of files</a></li>
<li><a href="#cleanup-after-restore">Cleanup after Restore</a></li>
<li><a href="#clearing-the-bvfs-cache">Clearing the BVFS Cache</a></li>
</ul></li>
</ul></li>
<li><a href="#tls-chaptertls">TLS {#<em>Chapter</em>TLS}</a><ul>
<li><a href="#introduction-to-tls">Introduction to TLS</a></li>
<li><a href="#new-configuration-directives">New Configuration Directives</a></li>
<li><a href="#tls-api-implementation">TLS API Implementation</a><ul>
<li><a href="#library-initialization-and-cleanup">Library Initialization and Cleanup</a></li>
<li><a href="#manipulating-tls-contexts">Manipulating TLS Contexts</a></li>
<li><a href="#performing-post-connection-verification">Performing Post-Connection Verification</a></li>
<li><a href="#manipulating-tls-connections">Manipulating TLS Connections</a></li>
</ul></li>
<li><a href="#bnet-api-changes">Bnet API Changes</a><ul>
<li><a href="#negotiating-a-tls-connection">Negotiating a TLS Connection</a></li>
<li><a href="#manipulating-socket-blocking-state">Manipulating Socket Blocking State</a></li>
</ul></li>
<li><a href="#authentication-negotiation">Authentication Negotiation</a></li>
<li><a href="#setting-up-regession-testing">Setting up Regession Testing</a></li>
<li><a href="#running-the-regression-script">Running the Regression Script</a><ul>
<li><a href="#setting-the-configuration-parameters">Setting the Configuration Parameters</a></li>
<li><a href="#building-the-test-bacula">Building the Test Bacula</a></li>
<li><a href="#setting-up-your-sql-engine">Setting up your SQL engine</a></li>
<li><a href="#running-the-disk-only-regression">Running the Disk Only Regression</a></li>
<li><a href="#other-tests">Other Tests</a></li>
<li><a href="#if-a-test-fails">If a Test Fails</a></li>
</ul></li>
<li><a href="#testing-a-binary-installation">Testing a Binary Installation</a></li>
<li><a href="#running-a-single-test">Running a Single Test</a></li>
<li><a href="#writing-a-regression-test">Writing a Regression Test</a><ul>
<li><a href="#running-the-tests-by-hand">Running the Tests by Hand</a></li>
<li><a href="#directory-structure">Directory Structure</a></li>
<li><a href="#adding-a-new-test">Adding a New Test</a></li>
<li><a href="#running-a-test-under-the-debugger">Running a Test Under The Debugger</a></li>
</ul></li>
</ul></li>
<li><a href="#MD5Chapter">Bacula MD5 Algorithm</a><ul>
<li><a href="#command-line-message-digest-utility">Command Line Message Digest Utility</a><ul>
<li><a href="#name">Name</a></li>
<li><a href="#synopsis">Synopsis</a></li>
<li><a href="#description">Description</a></li>
<li><a href="#options">Options</a></li>
<li><a href="#files">Files</a></li>
<li><a href="#bugs">Bugs</a></li>
</ul></li>
<li><a href="#zipped-archive">(Zipped archive)</a><ul>
<li><a href="#see-also">See Also</a></li>
<li><a href="#exit-status">Exit Status</a></li>
<li><a href="#copying">Copying</a></li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
</ul></li>
<li><a href="#general-5">General</a><ul>
<li><a href="#statically-allocated-memory">Statically Allocated Memory</a></li>
<li><a href="#dynamically-allocated-memory">Dynamically Allocated Memory</a></li>
<li><a href="#pooled-and-non-pooled-memory">Pooled and Non-pooled Memory</a></li>
</ul></li>
<li><a href="#general-6">General</a></li>
<li><a href="#bnet-and-threads">bnet and Threads</a></li>
<li><a href="#bnet_open">bnet_open</a></li>
<li><a href="#bnet_send">bnet_send</a></li>
<li><a href="#bnet_fsend">bnet_fsend</a></li>
<li><a href="#additional-error-information">Additional Error information</a></li>
<li><a href="#bnet_recv">bnet_recv</a></li>
<li><a href="#bnet_sig">bnet_sig</a></li>
<li><a href="#bnet_strerror">bnet_strerror</a></li>
<li><a href="#bnet_close">bnet_close</a></li>
<li><a href="#becoming-a-server">Becoming a Server</a></li>
<li><a href="#higher-level-conventions">Higher Level Conventions</a><ul>
<li><a href="#installing-smartalloc">Installing SMARTALLOC</a></li>
<li><a href="#squelching-a-smartalloc">Squelching a SMARTALLOC</a></li>
<li><a href="#living-with-libraries">Living with Libraries</a></li>
<li><a href="#smartalloc-details">SMARTALLOC Details</a></li>
<li><a href="#when-smartalloc-is-disabled">When SMARTALLOC is Disabled</a></li>
<li><a href="#the-alloc-function">The <span>alloc()</span> Function</a></li>
<li><a href="#overlays-and-underhandedness">Overlays and Underhandedness</a></li>
<li><a href="#test-and-demonstration-program">Test and Demonstration Program</a></li>
<li><a href="#invitation-to-the-hack">Invitation to the Hack</a></li>
</ul></li>
<li><a href="#zipped-archive-1">(Zipped archive)</a><ul>
<li><a href="#copying-1">Copying</a></li>
</ul></li>
</ul></li>
<li><a href="#gnu-free-documentation-license">GNU Free Documentation License</a></li>
</ul>
</div>
<p>Bacula Developer Notes {#_ChapterStart10} ======================</p>
<p>This document is intended mostly for developers and describes how you can contribute to the Bacula project and the the general framework of making Bacula source changes.</p>
<h3 id="contributions">Contributions</h3>
<p>Contributions to the Bacula project come in many forms: ideas, participation in helping people on the bacula-users email list, packaging Bacula binaries for the community, helping improve the documentation, and submitting code.</p>
<p>Contributions in the form of submissions for inclusion in the project are broken into two groups. The first are contributions that are aids and not essential to Bacula. In general, these will be scripts or will go into the <span><strong>bacula/examples</strong></span> directory. For these kinds of non-essential contributions there is no obligation to do a copyright assignment as described below. However, a copyright assignment would still be appreciated.</p>
<p>The second class of contributions are those which will be integrated with Bacula and become an essential part (code, scripts, documentation, …) Within this class of contributions, there are two hurdles to surmount. One is getting your patch accepted, and two is dealing with copyright issues. The following text describes some of the requirements for such code.</p>
<h3 id="patches">Patches</h3>
<p>Subject to the copyright assignment described below, your patches should be sent in <span><strong>git format-patch</strong></span> format relative to the current contents of the master branch of the Source Forge Git repository. Please attach the output file or files generated by the <span><strong>git format-patch</strong></span> to the email rather than include them directory to avoid wrapping of the lines in the patch. Please be sure to use the Bacula indenting standard (see below) for source code. If you have checked out the source with Git, you can get a diff using.</p>
<pre><code>git pull
git format-patch -M</code></pre>
<p>If you plan on doing significant development work over a period of time, after having your first patch reviewed and approved, you will be eligible for having developer Git write access so that you can commit your changes directly to the Git repository. To do so, you will need a userid on Source Forge.</p>
<h3 id="copyrights">Copyrights</h3>
<p>To avoid future problems concerning changing licensing or copyrights, all code contributions more than a hand full of lines must be in the Public Domain or have the copyright transferred to the Free Software Foundation Europe e.V. with a Fiduciary License Agreement (FLA) as the case for all the current code.</p>
<p>Prior to November 2004, all the code was copyrighted by Kern Sibbald and John Walker. After November 2004, the code was copyrighted by Kern Sibbald, then on the 15th of November 2006, Kern transferred the copyright to the Free Software Foundation Europe e.V. In signing the FLA and transferring the copyright, you retain the right to use the code you have submitted as you want, and you ensure that Bacula will always remain Free and Open Source.</p>
<p>Your name should be clearly indicated as the author of the code, and you must be extremely careful not to violate any copyrights or patents or use other people’s code without acknowledging it. The purpose of this requirement is to avoid future copyright, patent, or intellectual property problems. Please read the LICENSE agreement in the main Bacula source code directory. When you sign the Fiduciary License Agreement (FLA) and send it in, you are agreeing to the terms of that LICENSE file.</p>
<p>If you don’t understand what we mean by future problems, please examine the difficulties Mozilla was having finding previous contributors at <span>http://www.mozilla.org/MPL/missing.html</span>. The other important issue is to avoid copyright, patent, or intellectual property violations as was (May 2003) claimed by SCO against IBM.</p>
<p>Although the copyright will be held by the Free Software Foundation Europe e.V., each developer is expected to indicate that he wrote and/or modified a particular module (or file) and any other sources. The copyright assignment may seem a bit unusual, but in reality, it is not. Most large projects require this.</p>
<p>If you have any doubts about this, please don’t hesitate to ask. The objective is to assure the long term survival of the Bacula project.</p>
<p>Items not needing a copyright assignment are: most small changes, enhancements, or bug fixes of 5-10 lines of code, which amount to less than 20</p>
<h3 id="copyright-assignment-fiduciary-license-agreement">Copyright Assignment – Fiduciary License Agreement</h3>
<p>Since this is not a commercial enterprise, and we prefer to believe in everyone’s good faith, previously developers could assign the copyright by explicitly acknowledging that they do so in their first submission. This was sufficient if the developer is independent, or an employee of a not-for-profit organization or a university. However, in an effort to ensure that the Bacula code is really clean, beginning in August 2006, all previous and future developers with SVN write access will be asked to submit a copyright assignment (or Fiduciary License Agreement – FLA), which means you agree to the LICENSE in the main source directory. It also means that you receive back the right to use the code that you have submitted.</p>
<p>Any developer who wants to contribute and is employed by a company should either list the employer as the owner of the code, or get explicit permission from him to sign the copyright assignment. This is because in many countries, all work that an employee does whether on company time or in the employee’s free time is considered to be Intellectual Property of the company. Obtaining official approval or an FLA from the company will avoid misunderstandings between the employee, the company, and the Bacula project. A good number of companies have already followed this procedure.</p>
<p>The Fiduciary License Agreement is posted on the Bacula web site at:</p>
<p>The instructions for filling out this agreement are also at:</p>
<p>It should be filled out, then sent to:</p>
<pre><code>     Kern Sibbald
     Cotes-de-Montmoiret 9
     1012 Lausanne
     Switzerland</code></pre>
<p>Please note that the above address is different from the officially registered office mentioned in the document. When you send in such a complete document, please notify me: kern at sibbald dot com, and please add your email address to the FLA so that I can contact you to confirm reception of the signed FLA.</p>
<h2 id="the-development-cycle">The Development Cycle</h2>
<p>As discussed on the email lists, the number of contributions are increasing significantly. We expect this positive trend will continue. As a consequence, we have modified how we do development, and instead of making a list of all the features that we will implement in the next version, each developer signs up for one (maybe two) projects at a time, and when they are complete, and the code is stable, we will release a new version. The release cycle will probably be roughly six months.</p>
<p>The difference is that with a shorter release cycle and fewer released feature, we will have more time to review the new code that is being contributed, and will be able to devote more time to a smaller number of projects (some prior versions had too many new features for us to handle correctly).</p>
<p>Future release schedules will be much the same, and the number of new features will also be much the same providing that the contributions continue to come – and they show no signs of let up :-)</p>
<p><br />In addition, we have “formalizee” the feature requests a bit.</p>
<p>Instead of me maintaining an informal list of everything I run into (kernstodo), we now maintain a “formal” list of projects. This means that all new feature requests, including those recently discussed on the email lists, must be formally submitted and approved.</p>
<p>Formal submission of feature requests will take two forms:<br />1. non-mandatory, but highly recommended is to discuss proposed new features on the mailing list.<br />2. Formal submission of an Feature Request in a special format. We’ll give an example of this below, but you can also find it on the web site under “Support -<span>&gt;</span> Feature Requests”. Since it takes a bit of time to properly fill out a Feature Request form, you probably should check on the email list first.</p>
<p>Once the Feature Request is received by the keeper of the projects list, it will be sent to the Bacula project manager (Kern), and he will either accept it (90the time), send it to the email list asking for opinions, or reject it (very few cases).</p>
<p>If it is accepted, it will go in the “projects” file (a simple ASCII file) maintained in the main Bacula source directory.</p>
<p><span><strong>Implementation of Feature Requests:</strong></span><br />Any qualified developer can sign up for a project. The project must have an entry in the projects file, and the developer’s name will appear in the Status field.</p>
<p><span><strong>How Feature Requests are accepted:</strong></span><br />Acceptance of Feature Requests depends on several things:<br />1. feedback from users. If it is negative, the Feature Request will probably not be accepted.<br />2. the difficulty of the project. A project that is so difficult that we cannot imagine finding someone to implement probably won’t be accepted. Obviously if you know how to implement it, don’t hesitate to put it in your Feature Request<br />3. whether or not the Feature Request fits within the current strategy of Bacula (for example an Feature Request that requests changing the tape to tar format probably would not be accepted, …).</p>
<p><span><strong>How Feature Requests are prioritized:</strong></span><br />Once an Feature Request is accepted, it needs to be implemented. If you can find a developer for it, or one signs up for implementing it, then the Feature Request becomes top priority (at least for that developer).</p>
<p>Between releases of Bacula, we will generally solicit Feature Request input for the next version, and by way of this email, we suggest that you send discuss and send in your Feature Requests for the next release. Please verify that the Feature Request is not in the current list (attached to this email).</p>
<p>Once users have had several weeks to submit Feature Requests, the keeper of the projects list will organize them, and request users to vote on them. This will allow fixing prioritizing the Feature Requests. Having a priority is one thing, but getting it implement is another thing – we are hoping that the Bacula community will take more responsibility for assuring the implementation of accepted Feature Requests.</p>
<p>Feature Request format:</p>
<pre><code>============= Empty Feature Request form ===========
Item n:   One line summary ...
  Date:   Date submitted
  Origin: Name and email of originator.
  Status:

  What:   More detailed explanation ...

  Why:    Why it is important ...

  Notes:  Additional notes or features (omit if not used)
============== End Feature Request form ==============

============= Example Completed  Feature Request form ===========
Item 1:   Implement a Migration job type that will move the job
          data from one device to another.
  Origin: Sponsored by Riege Sofware International GmbH. Contact:
          Daniel Holtkamp &lt;holtkamp at riege dot com&gt;
  Date:   28 October 2005
  Status: Partially coded in 1.37 -- much more to do. Assigned to
          Kern.

  What:   The ability to copy, move, or archive data that is on a
          device to another device is very important.

  Why:    An ISP might want to backup to disk, but after 30 days
          migrate the data to tape backup and delete it from
          disk.  Bacula should be able to handle this
          automatically.  It needs to know what was put where,
          and when, and what to migrate -- it is a bit like
          retention periods.  Doing so would allow space to be
          freed up for current backups while maintaining older
          data on tape drives.

  Notes:  Migration could be triggered by:
           Number of Jobs
           Number of Volumes
           Age of Jobs
           Highwater size (keep total size)
           Lowwater mark
=================================================</code></pre>
<h2 id="bacula-code-submissions-and-projects">Bacula Code Submissions and Projects</h2>
<p>Getting code implemented in Bacula works roughly as follows:</p>
<ul>
<li><p>Kern is the project manager, but prefers not to be a “gate keeper”. This means that the developers are expected to be self-motivated, and once they have experience submit directly to the Git repositories. However, it is a good idea to have your patches reviewed prior to submitting, and it is a bad idea to submit monster patches because no one will be able to properly review them. See below for more details on this.</p></li>
<li><p>There are growing numbers of contributions (very good).</p></li>
<li><p>Some contributions come in the form of relatively small patches, which Kern reviews, integrates, documents, tests, and maintains.</p></li>
<li><p>All Bacula developers take full responsibility for writing the code, posting as patches so that we can review it as time permits, integrating it at an appropriate time, responding to our requests for tweaking it (name changes, …), document it in the code, document it in the manual (even though their mother tongue is not English), test it, develop and commit regression scripts, and answer in a timely fashion all bug reports – even occasionally accepting additional bugs :-)</p>
<p>This is a sustainable way of going forward with Bacula, and the direction that the project will be taking more and more. For example, in the past, we have had some very dedicated programmers who did major projects. However, some of these programmers due to outside obligations (job responsibilities change of job, school duties, …) could not continue to maintain the code. In those cases, the code suffers from lack of maintenance, sometimes we patch it, sometimes not. In the end, if the code is not maintained, the code gets dropped from the project (there are two such contributions that are heading in that direction). When ever possible, we would like to avoid this, and ensure a continuation of the code and a sharing of the development, debugging, documentation, and maintenance responsibilities.</p></li>
</ul>
<h2 id="patches-for-released-versions">Patches for Released Versions</h2>
<p>If you fix a bug in a released version, you should, unless it is an absolutely trivial bug, create and release a patch file for the bug. The procedure is as follows:</p>
<p>Fix the bug in the released branch and in the develpment master branch.</p>
<p>Make a patch file for the branch and add the branch patch to the patches directory in both the branch and the trunk. The name should be 2.2.4-xxx.patch where xxx is unique, in this case it can be “restore”, e.g. 2.2.4-restore.patch. Add to the top of the file a brief description and instructions for applying it – see for example 2.2.4-poll-mount.patch. The best way to create the patch file is as follows:</p>
<pre><code>  (edit) 2.2.4-restore.patch
  (input description)
  (end edit)

   git format-patch -M
   mv 0001-xxx 2.2.4-restore.patch</code></pre>
<p>check to make sure no extra junk got put into the patch file (i.e. it should have the patch for that bug only).</p>
<p>If there is not a bug report on the problem, create one, then add the patch to the bug report.</p>
<p>Then upload it to the 2.2.x release of bacula-patches.</p>
<p>So, end the end, the patch file is:</p>
<ul>
<li><p>Attached to the bug report</p></li>
<li><p>In Branch-2.2/bacula/patches/…</p></li>
<li><p>In the trunk</p></li>
<li><p>Loaded on Source Forge bacula-patches 2.2.x release. When you add it, click on the check box to send an Email so that all the users that are monitoring SF patches get notified.</p></li>
</ul>
<h2 id="developing-bacula">Developing Bacula</h2>
<p>Typically the simplest way to develop Bacula is to open one xterm window pointing to the source directory you wish to update; a second xterm window at the top source directory level, and a third xterm window at the bacula directory <span>&lt;</span>top<span>&gt;</span>/src/bacula. After making source changes in one of the directories, in the top source directory xterm, build the source, and start the daemons by entering:</p>
<p>make and</p>
<p>./startit then in the enter:</p>
<p>./console or</p>
<p>./gnome-console to start the Console program. Enter any commands for testing. For example: run kernsverify full.</p>
<p>Note, the instructions here to use <span><strong>./startit</strong></span> are different from using a production system where the administrator starts Bacula by entering <span><strong>./bacula start</strong></span>. This difference allows a development version of <span><strong>Bacula</strong></span> to be run on a computer at the same time that a production system is running. The <span><strong>./startit</strong></span> strip starts <span><strong>Bacula</strong></span> using a different set of configuration files, and thus permits avoiding conflicts with any production system.</p>
<p>To make additional source changes, exit from the Console program, and in the top source directory, stop the daemons by entering:</p>
<p>./stopit then repeat the process.</p>
<h3 id="debugging">Debugging</h3>
<p>Probably the first thing to do is to turn on debug output.</p>
<p>A good place to start is with a debug level of 20 as in <span><strong>./startit -d20</strong></span>. The startit command starts all the daemons with the same debug level. Alternatively, you can start the appropriate daemon with the debug level you want. If you really need more info, a debug level of 60 is not bad, and for just about everything a level of 200.</p>
<h3 id="using-a-debugger">Using a Debugger</h3>
<p>If you have a serious problem such as a segmentation fault, it can usually be found quickly using a good multiple thread debugger such as <span><strong>gdb</strong></span>. For example, suppose you get a segmentation violation in <span><strong>bacula-dir</strong></span>. You might use the following to find the problem:</p>
<p><span>&lt;</span>start the Storage and File daemons<span>&gt;</span> cd dird gdb ./bacula-dir run -f -s -c ./dird.conf <span>&lt;</span>it dies with a segmentation fault<span>&gt;</span> where The <span><strong>-f</strong></span> option is specified on the <span><strong>run</strong></span> command to inhibit <span><strong>dird</strong></span> from going into the background. You may also want to add the <span><strong>-s</strong></span> option to the run command to disable signals which can potentially interfere with the debugging.</p>
<p>As an alternative to using the debugger, each <span><strong>Bacula</strong></span> daemon has a built in back trace feature when a serious error is encountered. It calls the debugger on itself, produces a back trace, and emails the report to the developer. For more details on this, please see the chapter in the main Bacula manual entitled “What To Do When Bacula Crashes (Kaboom)”.</p>
<h3 id="memory-leaks">Memory Leaks</h3>
<p>Because Bacula runs routinely and unattended on client and server machines, it may run for a long time. As a consequence, from the very beginning, Bacula uses SmartAlloc to ensure that there are no memory leaks. To make detection of memory leaks effective, all Bacula code that dynamically allocates memory MUST have a way to release it. In general when the memory is no longer needed, it should be immediately released, but in some cases, the memory will be held during the entire time that Bacula is executing. In that case, there MUST be a routine that can be called at termination time that releases the memory. In this way, we will be able to detect memory leaks. Be sure to immediately correct any and all memory leaks that are printed at the termination of the daemons.</p>
<h3 id="special-files">Special Files</h3>
<p>Kern uses files named 1, 2, … 9 with any extension as scratch files. Thus any files with these names are subject to being rudely deleted at any time.</p>
<h3 id="when-implementing-incomplete-code">When Implementing Incomplete Code</h3>
<p>Please identify all incomplete code with a comment that contains</p>
<pre><code>***FIXME***</code></pre>
<p>where there are three asterisks (*) before and after the word FIXME (in capitals) and no intervening spaces. This is important as it allows new programmers to easily recognize where things are partially implemented.</p>
<h3 id="bacula-source-file-structure">Bacula Source File Structure</h3>
<p>The distribution generally comes as a tar file of the form <span><strong>bacula.x.y.z.tar.gz</strong></span> where x, y, and z are the version, release, and update numbers respectively.</p>
<p>Once you detar this file, you will have a directory structure as follows:</p>
<pre><code>|
Tar file:
|- depkgs
   |- mtx              (autochanger control program + tape drive info)
   |- sqlite           (SQLite database program)

Tar file:
|- depkgs-win32
   |- pthreads         (Native win32 pthreads library -- dll)
   |- zlib             (Native win32 zlib library)
   |- wx               (wxWidgets source code)

Project bacula:
|- bacula              (main source directory containing configuration
   |                    and installation files)
   |- autoconf         (automatic configuration files, not normally used
   |                    by users)
   |- intl             (programs used to translate)
   |- platforms        (OS specific installation files)
      |- redhat        (Red Hat installation)
      |- solaris       (Sun installation)
      |- freebsd       (FreeBSD installation)
      |- irix          (Irix installation -- not tested)
      |- unknown       (Default if system not identified)
   |- po               (translations of source strings)
   |- src              (source directory; contains global header files)
      |- cats          (SQL catalog database interface directory)
      |- console       (bacula user agent directory)
      |- dird          (Director daemon)
      |- filed         (Unix File daemon)
         |- win32      (Win32 files to make bacula-fd be a service)
      |- findlib       (Unix file find library for File daemon)
      |- gnome-console (GNOME version of console program)
      |- lib           (General Bacula library)
      |- stored        (Storage daemon)
      |- tconsole      (Tcl/tk console program -- not yet working)
      |- testprogs     (test programs -- normally only in Kern&#39;s tree)
      |- tools         (Various tool programs)
      |- win32         (Native Win32 File daemon)
         |- baculafd   (Visual Studio project file)
         |- compat     (compatibility interface library)
         |- filed      (links to src/filed)
         |- findlib    (links to src/findlib)
         |- lib        (links to src/lib)
         |- console    (beginning of native console program)
         |- wx-console (wxWidget console Win32 specific parts)
     |- wx-console     (wxWidgets console main source program)

Project regress:
|- regress             (Regression scripts)
   |- bin              (temporary directory to hold Bacula installed binaries)
   |- build            (temporary directory to hold Bacula source)
   |- scripts          (scripts and .conf files)
   |- tests            (test scripts)
   |- tmp              (temporary directory for temp files)
   |- working          (temporary working directory for Bacula daemons)

Project docs:
|- docs                (documentation directory)
   |- developers       (Developer&#39;s guide)
   |- home-page        (Bacula&#39;s home page source)
   |- manual           (html document directory)
   |- manual-fr        (French translation)
   |- manual-de        (German translation)
   |- techlogs         (Technical development notes);

Project rescue:
|- rescue              (Bacula rescue CDROM)
   |- linux            (Linux rescue CDROM)
      |- cdrom         (Linux rescue CDROM code)
        ...
   |- solaris          (Solaris rescue -- incomplete)
   |- freebsd          (FreeBSD rescue -- incomplete)

Project gui:
|- gui                 (Bacula GUI projects)
  |- bacula-web        (Bacula web php management code)
  |- bimagemgr         (Web application for burning CDROMs)</code></pre>
<h3 id="header-files">Header Files</h3>
<p>Please carefully follow the scheme defined below as it permits in general only two header file includes per C file, and thus vastly simplifies programming. With a large complex project like Bacula, it isn’t always easy to ensure that the right headers are invoked in the right order (there are a few kludges to make this happen – i.e. in a few include files because of the chicken and egg problem, certain references to typedefs had to be replaced with <span><strong>void</strong></span> ).</p>
<p>Every file should include <span><strong>bacula.h</strong></span>. It pulls in just about everything, with very few exceptions. If you have system dependent ifdefing, please do it in <span><strong>baconfig.h</strong></span>. The version number and date are kept in <span><strong>version.h</strong></span>.</p>
<p>Each of the subdirectories (console, cats, dird, filed, findlib, lib, stored, …) contains a single directory dependent include file generally the name of the directory, which should be included just after the include of <span><strong>bacula.h</strong></span>. This file (for example, for the dird directory, it is <span><strong>dird.h</strong></span>) contains either definitions of things generally needed in this directory, or it includes the appropriate header files. It always includes <span><strong>protos.h</strong></span>. See below.</p>
<p>Each subdirectory contains a header file named <span><strong>protos.h</strong></span>, which contains the prototypes for subroutines exported by files in that directory. <span><strong>protos.h</strong></span> is always included by the main directory dependent include file.</p>
<h3 id="programming-standards">Programming Standards</h3>
<p>For the most part, all code should be written in C unless there is a burning reason to use C++, and then only the simplest C++ constructs will be used. Note, Bacula is slowly evolving to use more and more C++.</p>
<p>Code should have some documentation – not a lot, but enough so that I can understand it. Look at the current code, and you will see that I document more than most, but am definitely not a fanatic.</p>
<p>We prefer simple linear code where possible. Gotos are strongly discouraged except for handling an error to either bail out or to retry some code, and such use of gotos can vastly simplify the program.</p>
<p>Remember this is a C program that is migrating to a <span><strong>tiny</strong></span> subset of C++, so be conservative in your use of C++ features.</p>
<h3 id="do-not-use">Do Not Use</h3>
<ul>
<li>STL – it is totally incomprehensible.</li>
</ul>
<h3 id="avoid-if-possible">Avoid if Possible</h3>
<ul>
<li><p>Using <span><strong>void *</strong></span> because this generally means that one must using casting, and in C++ casting is rather ugly. It is OK to use void * to pass structure address where the structure is not known to the routines accepting the packet (typically callback routines). However, declaring “void *buf” is a bad idea. Please use the correct types whenever possible.</p></li>
<li><p>Using undefined storage specifications such as (short, int, long, long long, size_t …). The problem with all these is that the number of bytes they allocate depends on the compiler and the system. Instead use Bacula’s types (int8_t, uint8_t, int32_t, uint32_t, int64_t, and uint64_t). This guarantees that the variables are given exactly the size you want. Please try at all possible to avoid using size_t ssize_t and the such. They are very system dependent. However, some system routines may need them, so their use is often unavoidable.</p></li>
<li><p>Returning a malloc’ed buffer from a subroutine – someone will forget to release it.</p></li>
<li><p>Heap allocation (malloc) unless needed – it is expensive. Use POOL_MEM instead.</p></li>
<li><p>Templates – they can create portability problems.</p></li>
<li><p>Fancy or tricky C or C++ code, unless you give a good explanation of why you used it.</p></li>
<li><p>Too much inheritance – it can complicate the code, and make reading it difficult (unless you are in love with colons)</p></li>
</ul>
<h3 id="do-use-whenever-possible">Do Use Whenever Possible</h3>
<ul>
<li><p>Locking and unlocking within a single subroutine.</p></li>
<li><p>A single point of exit from all subroutines. A goto is perfectly OK to use to get out early, but only to a label named bail_out, and possibly an ok_out. See current code examples.</p></li>
<li><p>malloc and free within a single subroutine.</p></li>
<li><p>Comments and global explanations on what your code or algorithm does.</p></li>
<li><p>When committing a fix for a bug, make the comment of the following form:</p>
<pre><code>Reason for bug fix or other message. Fixes bug #1234</code></pre>
<p>It is important to write the <span><strong>bug #1234</strong></span> like that because our program that automatically pulls messages from the git repository to make the ChangeLog looks for that pattern. Obviously the <span><strong>1234</strong></span> should be replaced with the number of the bug you actually fixed.</p>
<p>Providing the commit comment line has one of the following keywords (or phrases), it will be ignored:</p>
<pre><code>  tweak
  typo
  cleanup
  bweb:
  regress:
  again
  .gitignore
  fix compilation
  technotes
  update version
  update technotes
  update kernstodo
  update projects
  update releasenotes
  update version
  update home
  update release
  update todo
  update notes
  update changelog</code></pre></li>
<li><p>Use the following keywords at the beginning of a git commit message</p></li>
</ul>
<h3 id="indenting-standards">Indenting Standards</h3>
<p>We find it very hard to read code indented 8 columns at a time. Even 4 at a time uses a lot of space, so we have adopted indenting 3 spaces at every level. Note, indention is the visual appearance of the source on the page, while tabbing is replacing a series of up to 8 spaces from a tab character.</p>
<p>The closest set of parameters for the Linux <span><strong>indent</strong></span> program that will produce reasonably indented code are:</p>
<pre><code>-nbad -bap -bbo -nbc -br -brs -c36 -cd36 -ncdb -ce -ci3 -cli0
-cp36 -d0 -di1 -ndj -nfc1 -nfca -hnl -i3 -ip0 -l85 -lp -npcs
-nprs -npsl -saf -sai -saw -nsob -nss -nbc -ncs -nbfda</code></pre>
<p>You can put the above in your .indent.pro file, and then just invoke indent on your file. However, be warned. This does not produce perfect indenting, and it will mess up C++ class statements pretty badly.</p>
<p>Braces are required in all if statements (missing in some very old code). To avoid generating too many lines, the first brace appears on the first line (e.g. of an if), and the closing brace is on a line by itself. E.g.</p>
<pre><code>   if (abc) {
      some_code;
  }</code></pre>
<p>Just follow the convention in the code. For example we I prefer non-indented cases.</p>
<pre><code>   switch (code) {
   case &#39;A&#39;:
      do something
      break;
   case &#39;B&#39;:
      again();
      break;
   default:
      break;
  }</code></pre>
<p>Avoid using // style comments except for temporary code or turning off debug code. Standard C comments are preferred (this also keeps the code closer to C).</p>
<p>Attempt to keep all lines less than 85 characters long so that the whole line of code is readable at one time. This is not a rigid requirement.</p>
<p>Always put a brief description at the top of any new file created describing what it does and including your name and the date it was first written. Please don’t forget any Copyrights and acknowledgments if it isn’t 100% your code. Also, include the Bacula copyright notice that is in <span><strong>src/c</strong></span>.</p>
<p>In general you should have two includes at the top of the an include for the particular directory the code is in, for includes are needed, but this should be rare.</p>
<p>In general (except for self-contained packages), prototypes should all be put in <span><strong>protos.h</strong></span> in each directory.</p>
<p>Always put space around assignment and comparison operators.</p>
<pre><code>   a = 1;
   if (b &gt;= 2) {
     cleanup();
  }</code></pre>
<p>but your can compress things in a <span><strong>for</strong></span> statement:</p>
<pre><code>   for (i=0; i &lt; del.num_ids; i++) {
    ...</code></pre>
<p>Don’t overuse the inline if (?:). A full <span><strong>if</strong></span> is preferred, except in a print statement, e.g.:</p>
<pre><code>   if (ua-&gt;verbose \&amp;&amp; del.num_del != 0) {
      bsendmsg(ua, _(&quot;Pruned %d %s on Volume %s from catalog.\n&quot;), del.num_del,
         del.num_del == 1 ? &quot;Job&quot; : &quot;Jobs&quot;, mr-&gt;VolumeName);
  }</code></pre>
<p>Leave a certain amount of debug code (Dmsg) in code you submit, so that future problems can be identified. This is particularly true for complicated code likely to break. However, try to keep the debug code to a minimum to avoid bloating the program and above all to keep the code readable.</p>
<p>Please keep the same style in all new code you develop. If you include code previously written, you have the option of leaving it with the old indenting or re-indenting it. If the old code is indented with 8 spaces, then please re-indent it to Bacula standards.</p>
<p>If you are using <span><strong>vim</strong></span>, simply set your tabstop to 8 and your shiftwidth to 3.</p>
<h3 id="tabbing">Tabbing</h3>
<p>Tabbing (inserting the tab character in place of spaces) is as normal on all Unix systems – a tab is converted space up to the next column multiple of 8. My editor converts strings of spaces to tabs automatically – this results in significant compression of the files. Thus, you can remove tabs by replacing them with spaces if you wish. Please don’t confuse tabbing (use of tab characters) with indenting (visual alignment of the code).</p>
<h3 id="donts">Don’ts</h3>
<p>Please don’t use:</p>
<pre><code>strcpy()
strcat()
strncpy()
strncat();
sprintf()
snprintf()</code></pre>
<p>They are system dependent and un-safe. These should be replaced by the Bacula safe equivalents:</p>
<pre><code>char *bstrncpy(char *dest, char *source, int dest_size);
char *bstrncat(char *dest, char *source, int dest_size);
int bsnprintf(char *buf, int32_t buf_len, const char *fmt, ...);
int bvsnprintf(char *str, int32_t size, const char  *format, va_list ap);</code></pre>
<p>See src/lib/bsys.c for more details on these routines.</p>
<p>Don’t use the <span><strong>%lld</strong></span> or the <span><strong>%q</strong></span> printf format editing types to edit 64 bit integers – they are not portable. Instead, use <span><strong>%s</strong></span> with <span><strong>edit_uint64()</strong></span>. For example:</p>
<pre><code>   char buf[100];
   uint64_t num = something;
   char ed1[50];
   bsnprintf(buf, sizeof(buf), &quot;Num=%s\n&quot;, edit_uint64(num, ed1));</code></pre>
<p>Note: <span><strong>%lld</strong></span> is now permitted in Bacula code – we have our own printf routines which handle it correctly. The edit_uint64() subroutine can still be used if you wish, but over time, most of that old style will be removed.</p>
<p>The edit buffer <span><strong>ed1</strong></span> must be at least 27 bytes long to avoid overflow. See src/lib/edit.c for more details. If you look at the code, don’t start screaming that I use <span><strong>lld</strong></span>. I actually use subtle trick taught to me by John Walker. The <span><strong>lld</strong></span> that appears in the editing routine is actually <span><strong>#define</strong></span> to a what is needed on your OS (usually “lld” or “q”) and is defined in autoconf/configure.in for each OS. C string concatenation causes the appropriate string to be concatenated to the “%”.</p>
<p>Also please don’t use the STL or Templates or any complicated C++ code.</p>
<h3 id="message-classes">Message Classes</h3>
<p>Currently, there are five classes of messages: Debug, Error, Job, Memory, and Queued.</p>
<h3 id="debug-messages">Debug Messages</h3>
<p>Debug messages are designed to be turned on at a specified debug level and are always sent to STDOUT. There are designed to only be used in the development debug process. They are coded as:</p>
<p>DmsgN(level, message, arg1, …) where the N is a number indicating how many arguments are to be substituted into the message (i.e. it is a count of the number arguments you have in your message – generally the number of percent signs (%)). <span><strong>level</strong></span> is the debug level at which you wish the message to be printed. message is the debug message to be printed, and arg1, … are the arguments to be substituted. Since not all compilers support #defines with varargs, you must explicitly specify how many arguments you have.</p>
<p>When the debug message is printed, it will automatically be prefixed by the name of the daemon which is running, the filename where the Dmsg is, and the line number within the file.</p>
<p>Some actual examples are:</p>
<p>Dmsg2(20, “MD5len=%d MD5=%s\n”, strlen(buf), buf);</p>
<p>Dmsg1(9, “Created client %s record\n”, client-&gt;hdr.name);</p>
<h3 id="error-messages">Error Messages</h3>
<p>Error messages are messages that are related to the daemon as a whole rather than a particular job. For example, an out of memory condition my generate an error message. They should be very rarely needed. In general, you should be using Job and Job Queued messages (Jmsg and Qmsg). They are coded as:</p>
<p>EmsgN(error-code, level, message, arg1, …) As with debug messages, you must explicitly code the of arguments to be substituted in the message. error-code indicates the severity or class of error, and it may be one of the following:</p>
<p><span>lp<span>3in</span></span> <span><span><strong>M_ABORT</strong></span> </span> &amp; <span>Causes the daemon to immediately abort. This should be used only in extreme cases. It attempts to produce a traceback. </span><br /><span><span><strong>M_ERROR_TERM</strong></span> </span> &amp; <span>Causes the daemon to immediately terminate. This should be used only in extreme cases. It does not produce a traceback. </span><br /><span><span><strong>M_FATAL</strong></span> </span> &amp; <span>Causes the daemon to terminate the current job, but the daemon keeps running </span><br /><span><span><strong>M_ERROR</strong></span> </span> &amp; <span>Reports the error. The daemon and the job continue running </span><br /><span><span><strong>M_WARNING</strong></span> </span> &amp; <span>Reports an warning message. The daemon and the job continue running </span><br /><span><span><strong>M_INFO</strong></span> </span> &amp; <span>Reports an informational message.</span></p>
<p>There are other error message classes, but they are in a state of being redesigned or deprecated, so please do not use them. Some actual examples are:</p>
<p>Emsg1(M_ABORT, 0, “Cannot create message thread: %s\n”, strerror(status));</p>
<p>Emsg3(M_WARNING, 0, “Connect to File daemon %s at %s:%d failed. Retrying …\n”, client-<span>&gt;</span>hdr.name, client-<span>&gt;</span>address, client-<span>&gt;</span>port);</p>
<p>Emsg3(M_FATAL, 0, “bdird<span>&lt;</span>filed: bad response from Filed to %s command: %d %s\n”, cmd, n, strerror(errno));</p>
<h3 id="job-messages">Job Messages</h3>
<p>Job messages are messages that pertain to a particular job such as a file that could not be saved, or the number of files and bytes that were saved. They Are coded as:</p>
<pre><code>Jmsg(jcr, M\_FATAL, 0, &quot;Text of message&quot;);</code></pre>
<p>A Jmsg with M_FATAL will fail the job. The Jmsg() takes varargs so can have any number of arguments for substituted in a printf like format. Output from the Jmsg() will go to the Job report. &lt;br&gt; If the Jmsg is followed with a number such as Jmsg1(…), the number indicates the number of arguments to be substituted (varargs is not standard for #defines), and what is more important is that the file and line number will be prefixed to the message. This permits a sort of debug from user’s output.</p>
<h3 id="queued-job-messages">Queued Job Messages</h3>
<p>Queued Job messages are similar to Jmsg()s except that the message is Queued rather than immediately dispatched. This is necessary within the network subroutines and in the message editing routines. This is to prevent recursive loops, and to ensure that messages can be delivered even in the event of a network error.</p>
<h3 id="memory-messages">Memory Messages</h3>
<p>Memory messages are messages that are edited into a memory buffer. Generally they are used in low level routines such as the low level device file dev.c in the Storage daemon or in the low level Catalog routines. These routines do not generally have access to the Job Control Record and so they return error essages reformatted in a memory buffer. Mmsg() is the way to do this.</p>
<h3 id="bugs-database">Bugs Database</h3>
<p>We have a bugs database which is at: , and as a developer you will need to respond to bugs, perhaps bugs in general if you have time, otherwise just bugs that correspond to code that you wrote.</p>
<p>If you need to answer bugs, please be sure to ask the Project Manager (currently Kern) to give you Developer access to the bugs database. This allows you to modify statuses and close bugs.</p>
<p>The first thing is if you want to take over a bug, rather than just make a note, you should assign the bug to yourself. This helps other developers know that you are the principal person to deal with the bug. You can do so by going into the bug and clicking on the <span><strong>Update Issue</strong></span> button. Then you simply go to the <span><strong>Assigned To</strong></span> box and select your name from the drop down box. To actually update it you must click on the <span><strong>Update Information</strong></span> button a bit further down on the screen, but if you have other things to do such as add a Note, you might wait before clicking on the <span><strong>Update Information</strong></span> button.</p>
<p>Generally, we set the <span><strong>Status</strong></span> field to either acknowledged, confirmed, or feedback when we first start working on the bug. Feedback is set when we expect that the user should give us more information.</p>
<p>Normally, once you are reasonably sure that the bug is fixed, and a patch is made and attached to the bug report, and/or in the SVN, you can close the bug. If you want the user to test the patch, then leave the bug open, otherwise close it and set <span><strong>Resolution</strong></span> to <span><strong>Fixed</strong></span>. We generally close bug reports rather quickly, even without confirmation, especially if we have run tests and can see that for us the problem is fixed. However, in doing so, it avoids misunderstandings if you leave a note while you are closing the bug that says something to the following effect: We are closing this bug because … If for some reason, it does not fix your problem, please feel free to reopen it, or to open a new bug report describing the problem“.</p>
<p>We do not recommend that you attempt to edit any of the bug notes that have been submitted, nor to delete them or make them private. In fact, if someone accidentally makes a bug note private, you should ask the reason and if at all possible (with his agreement) make the bug note public.</p>
<p>If the user has not properly filled in most of the important fields (platorm, OS, Product Version, …) please do not hesitate to politely ask him. Also, if the bug report is a request for a new feature, please politely send the user to the Feature Request menu item on www.bacula.org. The same applies to a support request (we answer only bugs), you might give the user a tip, but please politely refer him to the manual and the Getting Support page of www.bacula.org.</p>
<h1 id="bacula-fd-plugin-api">Bacula FD Plugin API</h1>
<p>To write a Bacula plugin, you create a dynamic shared object program (or dll on Win32) with a particular name and two exported entry points, place it in the <span><strong>Plugins Directory</strong></span>, which is defined in the <span><strong>bacula-fd.conf</strong></span> file in the <span><strong>Client</strong></span> resource, and when the FD starts, it will load all the plugins that end with <span><strong>-fd.so</strong></span> (or <span><strong>-fd.dll</strong></span> on Win32) found in that directory.</p>
<h2 id="normal-vs-command-vs-options-plugins">Normal vs Command vs Options Plugins</h2>
<p>In general, there are three ways that plugins are called. The first way, is when a particular event is detected in Bacula, it will transfer control to each plugin that is loaded in turn informing the plugin of the event. This is very similar to how a <span><strong>RunScript</strong></span> works, and the events are very similar. Once the plugin gets control, it can interact with Bacula by getting and setting Bacula variables. In this way, it behaves much like a RunScript. Currently very few Bacula variables are defined, but they will be implemented as the need arises, and it is very extensible.</p>
<p>We plan to have plugins register to receive events that they normally would not receive, such as an event for each file examined for backup or restore. This feature is not yet implemented.</p>
<p>The second type of plugin, which is more useful and fully implemented in the current version is what we call a command plugin. As with all plugins, it gets notified of important events as noted above (details described below), but in addition, this kind of plugin can accept a command line, which is a:</p>
<pre><code>   Plugin = &lt;command-string&gt;</code></pre>
<p>directive that is placed in the Include section of a FileSet and is very similar to the “File =” directive. When this Plugin directive is encountered by Bacula during backup, it passes the “command” part of the Plugin directive only to the plugin that is explicitly named in the first field of that command string. This allows that plugin to backup any file or files on the system that it wants. It can even create “virtual files” in the catalog that contain data to be restored but do not necessarily correspond to actual files on the filesystem.</p>
<p>The important features of the command plugin entry points are:</p>
<ul>
<li><p>It is triggered by a “Plugin =” directive in the FileSet</p></li>
<li><p>Only a single plugin is called that is named on the “Plugin =” directive.</p></li>
<li><p>The full command string after the “Plugin =” is passed to the plugin so that it can be told what to backup/restore.</p></li>
</ul>
<p>The third type of plugin is the Options Plugin, this kind of plugin is useful to implement some custom filter on data. For example, you can implement a compression algorithm in a very simple way. Bacula will call this plugin for each file that is selected in a FileSet (according to Wild/Regex/Exclude/Include rules). As with all plugins, it gets notified of important events as noted above (details described below), but in addition, this kind of plugin can be placed in a Options group, which is a:</p>
<pre><code> FileSet {
    Name = TestFS
    Include {
       Options {
          Compression = GZIP1
          Signature = MD5
          Wild = &quot;*.txt&quot;
          Plugin = &lt;command-string&gt;
       }
       File = /
    }
}</code></pre>
<h2 id="loading-plugins">Loading Plugins</h2>
<p>Once the File daemon loads the plugins, it asks the OS for the two entry points (loadPlugin and unloadPlugin) then calls the <span><strong>loadPlugin</strong></span> entry point (see below).</p>
<p>Bacula passes information to the plugin through this call and it gets back information that it needs to use the plugin. Later, Bacula will call particular functions that are defined by the <span><strong>loadPlugin</strong></span> interface.</p>
<p>When Bacula is finished with the plugin (when Bacula is going to exit), it will call the <span><strong>unloadPlugin</strong></span> entry point.</p>
<p>The two entry points are:</p>
<pre><code>bRC loadPlugin(bInfo *lbinfo, bFuncs *lbfuncs, pInfo **pinfo, pFuncs **pfuncs)

and

bRC unloadPlugin()</code></pre>
<p>both these external entry points to the shared object are defined as C entry points to avoid name mangling complications with C++. However, the shared object can actually be written in any language (preferably C or C++) providing that it follows C language calling conventions.</p>
<p>The definitions for <span><strong>bRC</strong></span> and the arguments are <span><strong>src/filed/fd-plugins.h</strong></span> and so this header file needs to be included in your plugin. It along with <span><strong>src/lib/plugins.h</strong></span> define basically the whole plugin interface. Within this header file, it includes the following files:</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &quot;config.h&quot;
#include &quot;bc_types.h&quot;
#include &quot;lib/plugins.h&quot;
#include &lt;sys/stat.h&gt;</code></pre>
<p>Aside from the <span><strong>bc_types.h</strong></span> and <span><strong>confit.h</strong></span> headers, the plugin definition uses the minimum code from Bacula. The bc_types.h file is required to ensure that the data type definitions in arguments correspond to the Bacula core code.</p>
<p>The return codes are defined as:</p>
<pre><code>typedef enum {
  bRC_OK    = 0,                         /* OK */
  bRC_Stop  = 1,                         /* Stop calling other plugins */
  bRC_Error = 2,                         /* Some kind of error */
  bRC_More  = 3,                         /* More files to backup */
  bRC_Term  = 4,                         /* Unload me */
  bRC_Seen  = 5,                         /* Return code from checkFiles */
  bRC_Core  = 6,                         /* Let Bacula core handles this file */
  bRC_Skip  = 7,                         /* Skip the proposed file */
} bRC;</code></pre>
<p>At a future point in time, we hope to make the Bacula libbac.a into a shared object so that the plugin can use much more of Bacula’s infrastructure, but for this first cut, we have tried to minimize the dependence on Bacula.</p>
<h2 id="loadplugin">loadPlugin</h2>
<p>As previously mentioned, the <span><strong>loadPlugin</strong></span> entry point in the plugin is called immediately after Bacula loads the plugin when the File daemon itself is first starting. This entry point is only called once during the execution of the File daemon. In calling the plugin, the first two arguments are information from Bacula that is passed to the plugin, and the last two arguments are information about the plugin that the plugin must return to Bacula. The call is:</p>
<pre><code>bRC loadPlugin(bInfo *lbinfo, bFuncs *lbfuncs, pInfo **pinfo, pFuncs **pfuncs)</code></pre>
<p>and the arguments are:</p>
<dl>
<dt>lbinfo</dt>
<dd><p>This is information about Bacula in general. Currently, the only value defined in the bInfo structure is the version, which is the Bacula plugin interface version, currently defined as 1. The <span><strong>size</strong></span> is set to the byte size of the structure. The exact definition of the bInfo structure as of this writing is:</p>
<pre><code>typedef struct s_baculaInfo {
   uint32_t size;
   uint32_t version;
} bInfo;</code></pre>
</dd>
<dt>lbfuncs</dt>
<dd><p>The bFuncs structure defines the callback entry points within Bacula that the plugin can use register events, get Bacula values, set Bacula values, and send messages to the Job output or debug output.</p>
<p>The exact definition as of this writing is:</p>
<pre><code>typedef struct s_baculaFuncs {
   uint32_t size;
   uint32_t version;
   bRC (*registerBaculaEvents)(bpContext *ctx, ...);
   bRC (*getBaculaValue)(bpContext *ctx, bVariable var, void *value);
   bRC (*setBaculaValue)(bpContext *ctx, bVariable var, void *value);
   bRC (*JobMessage)(bpContext *ctx, const char *file, int line,
       int type, utime_t mtime, const char *fmt, ...);
   bRC (*DebugMessage)(bpContext *ctx, const char *file, int line,
       int level, const char *fmt, ...);
   void *(*baculaMalloc)(bpContext *ctx, const char *file, int line,
       size_t size);
   void (*baculaFree)(bpContext *ctx, const char *file, int line, void *mem);
} bFuncs;</code></pre>
<p>We will discuss these entry points and how to use them a bit later when describing the plugin code.</p>
</dd>
<dt>pInfo</dt>
<dd><p>When the loadPlugin entry point is called, the plugin must initialize an information structure about the plugin and return a pointer to this structure to Bacula.</p>
<p>The exact definition as of this writing is:</p>
<pre><code>typedef struct s_pluginInfo {
   uint32_t size;
   uint32_t version;
   const char *plugin_magic;
   const char *plugin_license;
   const char *plugin_author;
   const char *plugin_date;
   const char *plugin_version;
   const char *plugin_description;
} pInfo;</code></pre>
<p>Where:</p>
<dl>
<dt>version</dt>
<dd><p>is the current Bacula defined plugin interface version, currently set to 1. If the interface version differs from the current version of Bacula, the plugin will not be run (not yet implemented).</p>
</dd>
<dt>plugin_magic</dt>
<dd><p>is a pointer to the text string “*FDPluginData*”, a sort of sanity check. If this value is not specified, the plugin will not be run (not yet implemented).</p>
</dd>
<dt>plugin_license</dt>
<dd><p>is a pointer to a text string that describes the plugin license. Bacula will only accept compatible licenses (not yet implemented).</p>
</dd>
<dt>plugin_author</dt>
<dd><p>is a pointer to the text name of the author of the program. This string can be anything but is generally the author’s name.</p>
</dd>
<dt>plugin_date</dt>
<dd><p>is the pointer text string containing the date of the plugin. This string can be anything but is generally some human readable form of the date.</p>
</dd>
<dt>plugin_version</dt>
<dd><p>is a pointer to a text string containing the version of the plugin. The contents are determined by the plugin writer.</p>
</dd>
<dt>plugin_description</dt>
<dd><p>is a pointer to a string describing what the plugin does. The contents are determined by the plugin writer.</p>
</dd>
</dl>
<p>The pInfo structure must be defined in static memory because Bacula does not copy it and may refer to the values at any time while the plugin is loaded. All values must be supplied or the plugin will not run (not yet implemented). All text strings must be either ASCII or UTF-8 strings that are terminated with a zero byte.</p>
</dd>
<dt>pFuncs</dt>
<dd><p>When the loadPlugin entry point is called, the plugin must initialize an entry point structure about the plugin and return a pointer to this structure to Bacula. This structure contains pointer to each of the entry points that the plugin must provide for Bacula. When Bacula is actually running the plugin, it will call the defined entry points at particular times. All entry points must be defined.</p>
<p>The pFuncs structure must be defined in static memory because Bacula does not copy it and may refer to the values at any time while the plugin is loaded.</p>
<p>The exact definition as of this writing is:</p>
<pre><code>typedef struct s_pluginFuncs {
   uint32_t size;
   uint32_t version;
   bRC (*newPlugin)(bpContext *ctx);
   bRC (*freePlugin)(bpContext *ctx);
   bRC (*getPluginValue)(bpContext *ctx, pVariable var, void *value);
   bRC (*setPluginValue)(bpContext *ctx, pVariable var, void *value);
   bRC (*handlePluginEvent)(bpContext *ctx, bEvent *event, void *value);
   bRC (*startBackupFile)(bpContext *ctx, struct save_pkt *sp);
   bRC (*endBackupFile)(bpContext *ctx);
   bRC (*startRestoreFile)(bpContext *ctx, const char *cmd);
   bRC (*endRestoreFile)(bpContext *ctx);
   bRC (*pluginIO)(bpContext *ctx, struct io_pkt *io);
   bRC (*createFile)(bpContext *ctx, struct restore_pkt *rp);
   bRC (*setFileAttributes)(bpContext *ctx, struct restore_pkt *rp);
   bRC (*checkFile)(bpContext *ctx, char *fname);
} pFuncs;</code></pre>
<p>The details of the entry points will be presented in separate sections below.</p>
<p>Where:</p>
<dl>
<dt>size</dt>
<dd><p>is the byte size of the structure.</p>
</dd>
<dt>version</dt>
<dd><p>is the plugin interface version currently set to 3.</p>
</dd>
</dl>
<p>Sample code for loadPlugin:</p>
<pre><code>  bfuncs = lbfuncs;                  /* set Bacula funct pointers */
  binfo  = lbinfo;
  *pinfo  = &amp;pluginInfo;             /* return pointer to our info */
  *pfuncs = &amp;pluginFuncs;            /* return pointer to our functions */

   return bRC_OK;</code></pre>
<p>where pluginInfo and pluginFuncs are statically defined structures. See bpipe-fd.c for details.</p>
</dd>
</dl>
<h2 id="plugin-entry-points">Plugin Entry Points</h2>
<p>This section will describe each of the entry points (subroutines) within the plugin that the plugin must provide for Bacula, when they are called and their arguments. As noted above, pointers to these subroutines are passed back to Bacula in the pFuncs structure when Bacula calls the loadPlugin() externally defined entry point.</p>
<h3 id="newpluginbpcontext-ctx">newPlugin(bpContext *ctx)</h3>
<p>This is the entry point that Bacula will call when a new “instance” of the plugin is created. This typically happens at the beginning of a Job. If 10 Jobs are running simultaneously, there will be at least 10 instances of the plugin.</p>
<p>The bpContext structure will be passed to the plugin, and during this call, if the plugin needs to have its private working storage that is associated with the particular instance of the plugin, it should create it from the heap (malloc the memory) and store a pointer to its private working storage in the <span><strong>pContext</strong></span> variable. Note: since Bacula is a multi-threaded program, you must not keep any variable data in your plugin unless it is truly meant to apply globally to the whole plugin. In addition, you must be aware that except the first and last call to the plugin (loadPlugin and unloadPlugin) all the other calls will be made by threads that correspond to a Bacula job. The bpContext that will be passed for each thread will remain the same throughout the Job thus you can keep your private Job specific data in it (<span><strong>bContext</strong></span>).</p>
<pre><code>typedef struct s_bpContext {
  void *pContext;   /* Plugin private context */
  void *bContext;   /* Bacula private context */
} bpContext;</code></pre>
<p>This context pointer will be passed as the first argument to all the entry points that Bacula calls within the plugin. Needless to say, the plugin should not change the bContext variable, which is Bacula’s private context pointer for this instance (Job) of this plugin.</p>
<h3 id="freepluginbpcontext-ctx">freePlugin(bpContext *ctx)</h3>
<p>This entry point is called when the this instance of the plugin is no longer needed (the Job is ending), and the plugin should release all memory it may have allocated for this particular instance (Job) i.e. the pContext. This is not the final termination of the plugin signaled by a call to <span><strong>unloadPlugin</strong></span>. Any other instances (Job) will continue to run, and the entry point <span><strong>newPlugin</strong></span> may be called again if other jobs start.</p>
<h3 id="getpluginvaluebpcontext-ctx-pvariable-var-void-value">getPluginValue(bpContext *ctx, pVariable var, void *value)</h3>
<p>Bacula will call this entry point to get a value from the plugin. This entry point is currently not called.</p>
<h3 id="setpluginvaluebpcontext-ctx-pvariable-var-void-value">setPluginValue(bpContext *ctx, pVariable var, void *value)</h3>
<p>Bacula will call this entry point to set a value in the plugin. This entry point is currently not called.</p>
<h3 id="handleplugineventbpcontext-ctx-bevent-event-void-value">handlePluginEvent(bpContext *ctx, bEvent *event, void *value)</h3>
<p>This entry point is called when Bacula encounters certain events (discussed below). This is, in fact, the main way that most plugins get control when a Job runs and how they know what is happening in the job. It can be likened to the <span><strong>RunScript</strong></span> feature that calls external programs and scripts, and is very similar to the Bacula Python interface. When the plugin is called, Bacula passes it the pointer to an event structure (bEvent), which currently has one item, the eventType:</p>
<pre><code>typedef struct s_bEvent {
   uint32_t eventType;
} bEvent;</code></pre>
<p>which defines what event has been triggered, and for each event, Bacula will pass a pointer to a value associated with that event. If no value is associated with a particular event, Bacula will pass a NULL pointer, so the plugin must be careful to always check value pointer prior to dereferencing it.</p>
<p>The current list of events are:</p>
<pre><code>typedef enum {
  bEventJobStart                        = 1,
  bEventJobEnd                          = 2,
  bEventStartBackupJob                  = 3,
  bEventEndBackupJob                    = 4,
  bEventStartRestoreJob                 = 5,
  bEventEndRestoreJob                   = 6,
  bEventStartVerifyJob                  = 7,
  bEventEndVerifyJob                    = 8,
  bEventBackupCommand                   = 9,
  bEventRestoreCommand                  = 10,
  bEventLevel                           = 11,
  bEventSince                           = 12,
  bEventCancelCommand                   = 13,  /* Executed by another thread */

  /* Just before bEventVssPrepareSnapshot */
  bEventVssBackupAddComponents          = 14,

  bEventVssRestoreLoadComponentMetadata = 15,
  bEventVssRestoreSetComponentsSelected = 16,
  bEventRestoreObject                   = 17,
  bEventEndFileSet                      = 18,
  bEventPluginCommand                   = 19,
  bEventVssBeforeCloseRestore           = 21,

  /* Add drives to VSS snapshot
   *  argument: char[27] drivelist
   * You need to add them without duplicates,
   * see fd_common.h add_drive() copy_drives() to get help
   */
  bEventVssPrepareSnapshot              = 22,
  bEventOptionPlugin                    = 23,
  bEventHandleBackupFile                = 24 /* Used with Options Plugin */

} bEventType;</code></pre>
<p>Most of the above are self-explanatory.</p>
<dl>
<dt>bEventJobStart</dt>
<dd><p>is called whenever a Job starts. The value passed is a pointer to a string that contains: “Jobid=nnn Job=job-name”. Where nnn will be replaced by the JobId and job-name will be replaced by the Job name. The variable is temporary so if you need the values, you must copy them.</p>
</dd>
<dt>bEventJobEnd</dt>
<dd><p>is called whenever a Job ends. No value is passed.</p>
</dd>
<dt>bEventStartBackupJob</dt>
<dd><p>is called when a Backup Job begins. No value is passed.</p>
</dd>
<dt>bEventEndBackupJob</dt>
<dd><p>is called when a Backup Job ends. No value is passed.</p>
</dd>
<dt>bEventStartRestoreJob</dt>
<dd><p>is called when a Restore Job starts. No value is passed.</p>
</dd>
<dt>bEventEndRestoreJob</dt>
<dd><p>is called when a Restore Job ends. No value is passed.</p>
</dd>
<dt>bEventStartVerifyJob</dt>
<dd><p>is called when a Verify Job starts. No value is passed.</p>
</dd>
<dt>bEventEndVerifyJob</dt>
<dd><p>is called when a Verify Job ends. No value is passed.</p>
</dd>
<dt>bEventBackupCommand</dt>
<dd><p>is called prior to the bEventStartBackupJob and the plugin is passed the command string (everything after the equal sign in “Plugin =” as the value.</p>
<p>Note, if you intend to backup a file, this is an important first point to write code that copies the command string passed into your pContext area so that you will know that a backup is being performed and you will know the full contents of the “Plugin =” command (i.e. what to backup and what virtual filename the user wants to call it.</p>
</dd>
<dt>bEventRestoreCommand</dt>
<dd><p>is called prior to the bEventStartRestoreJob and the plugin is passed the command string (everything after the equal sign in “Plugin =” as the value.</p>
<p>See the notes above concerning backup and the command string. This is the point at which Bacula passes you the original command string that was specified during the backup, so you will want to save it in your pContext area for later use when Bacula calls the plugin again.</p>
</dd>
<dt>bEventLevel</dt>
<dd><p>is called when the level is set for a new Job. The value is a 32 bit integer stored in the void*, which represents the Job Level code.</p>
</dd>
<dt>bEventSince</dt>
<dd><p>is called when the since time is set for a new Job. The value is a time_t time at which the last job was run.</p>
</dd>
<dt>bEventCancelCommand</dt>
<dd><p>is called whenever the currently running Job is cancelled. Be warned that this event is sent by a different thread.</p>
</dd>
<dt>bEventVssBackupAddComponents</dt>
<dd>
</dd>
<dt>bEventPluginCommand</dt>
<dd><p>is called for each PluginCommand present in the current FileSet. The event will be sent only on plugin specifed in the command. The argument is the PluginCommand (not valid after the call).</p>
</dd>
<dt>bEventHandleBackupFile</dt>
<dd><p>is called for each file of a FileSet when using a Options Plugin. If the plugin returns CF_OK, it will be used for the backup, if it returns CF_SKIP, the file will be skipped. Anything else will backup the file with Bacula core functions.</p>
</dd>
</dl>
<p>During each of the above calls, the plugin receives either no specific value or only one value, which in some cases may not be sufficient. However, knowing the context of the event, the plugin can call back to the Bacula entry points it was passed during the <span><strong>loadPlugin</strong></span> call and get to a number of Bacula variables. (at the current time few Bacula variables are implemented, but it easily extended at a future time and as needs require).</p>
<h3 id="startbackupfilebpcontext-ctx-struct-save_pkt-sp">startBackupFile(bpContext *ctx, struct save_pkt *sp)</h3>
<p>This entry point is called only if your plugin is a command plugin, and it is called when Bacula encounters the “Plugin =” directive in the Include section of the FileSet. Called when beginning the backup of a file. Here Bacula provides you with a pointer to the <span><strong>save_pkt</strong></span> structure and you must fill in this packet with the “attribute” data of the file.</p>
<pre><code>struct save_pkt {
   int32_t pkt_size;                  /* size of this packet */
   char *fname;                       /* Full path and filename */
   char *link;                        /* Link name if any */
   struct stat statp;                 /* System stat() packet for file */
   int32_t type;                      /* FT_xx for this file */
   uint32_t flags;                    /* Bacula internal flags */
   bool portable;                     /* set if data format is portable */
   char *cmd;                         /* command */
   uint32_t delta_seq;                /* Delta sequence number */
   char *object_name;                 /* Object name to create */
   char *object;                      /* restore object data to save */
   int32_t object_len;                /* restore object length */
   int32_t index;                     /* restore object index */
   int32_t pkt_end;                   /* end packet sentinel */
};</code></pre>
<p>The second argument is a pointer to the <span><strong>save_pkt</strong></span> structure for the file to be backed up. The plugin is responsible for filling in all the fields of the <span><strong>save_pkt</strong></span>. If you are backing up a real file, then generally, the statp structure can be filled in by doing a <span><strong>stat</strong></span> system call on the file.</p>
<p>If you are backing up a database or something that is more complex, you might want to create a virtual file. That is a file that does not actually exist on the filesystem, but represents say an object that you are backing up. In that case, you need to ensure that the <span><strong>fname</strong></span> string that you pass back is unique so that it does not conflict with a real file on the system, and you need to artifically create values in the statp packet.</p>
<p>Example programs such as <span><strong>bpipe-fd.c</strong></span> show how to set these fields. You must take care not to store pointers the stack in the pointer fields such as fname and link, because when you return from your function, your stack entries will be destroyed. The solution in that case is to malloc() and return the pointer to it. In order to not have memory leaks, you should store a pointer to all memory allocated in your pContext structure so that in subsequent calls or at termination, you can release it back to the system.</p>
<p>Once the backup has begun, Bacula will call your plugin at the <span><strong>pluginIO</strong></span> entry point to “read” the data to be backed up. Please see the <span><strong>bpipe-fd.c</strong></span> plugin for how to do I/O.</p>
<p>Example of filling in the save_pkt as used in bpipe-fd.c:</p>
<pre><code>   struct plugin_ctx *p_ctx = (struct plugin_ctx *)ctx-&gt;pContext;
   time_t now = time(NULL);
   sp-&gt;fname = p_ctx-&gt;fname;
   sp-&gt;statp.st_mode = 0700 | S_IFREG;
   sp-&gt;statp.st_ctime = now;
   sp-&gt;statp.st_mtime = now;
   sp-&gt;statp.st_atime = now;
   sp-&gt;statp.st_size = -1;
   sp-&gt;statp.st_blksize = 4096;
   sp-&gt;statp.st_blocks = 1;
   p_ctx-&gt;backup = true;
   return bRC_OK;</code></pre>
<p>Note: the filename to be created has already been created from the command string previously sent to the plugin and is in the plugin context (p_ctx-&gt;fname) and is a malloc()ed string. This example creates a regular file (S_IFREG), with various fields being created.</p>
<p>In general, the sequence of commands issued from Bacula to the plugin to do a backup while processing the “Plugin =” directive are:</p>
<ol style="list-style-type: decimal">
<li><p>generate a bEventBackupCommand event to the specified plugin and pass it the command string.</p></li>
<li><p>make a startPluginBackup call to the plugin, which fills in the data needed in save_pkt to save as the file attributes and to put on the Volume and in the catalog.</p></li>
<li><p>call Bacula’s internal save_file() subroutine to save the specified file. The plugin will then be called at pluginIO() to “open” the file, and then to read the file data. Note, if you are dealing with a virtual file, the “open” operation is something the plugin does internally and it doesn’t necessarily mean opening a file on the filesystem. For example in the case of the bpipe-fd.c program, it initiates a pipe to the requested program. Finally when the plugin signals to Bacula that all the data was read, Bacula will call the plugin with the “close” pluginIO() function.</p></li>
</ol>
<h3 id="endbackupfilebpcontext-ctx">endBackupFile(bpContext *ctx)</h3>
<p>Called at the end of backing up a file for a command plugin. If the plugin’s work is done, it should return bRC_OK. If the plugin wishes to create another file and back it up, then it must return bRC_More (not yet implemented). This is probably a good time to release any malloc()ed memory you used to pass back filenames.</p>
<h3 id="startrestorefilebpcontext-ctx-const-char-cmd">startRestoreFile(bpContext *ctx, const char *cmd)</h3>
<p>Called when the first record is read from the Volume that was previously written by the command plugin.</p>
<h3 id="createfilebpcontext-ctx-struct-restore_pkt-rp">createFile(bpContext *ctx, struct restore_pkt *rp)</h3>
<p>Called for a command plugin to create a file during a Restore job before restoring the data. This entry point is called before any I/O is done on the file. After this call, Bacula will call pluginIO() to open the file for write.</p>
<p>The data in the restore_pkt is passed to the plugin and is based on the data that was originally given by the plugin during the backup and the current user restore settings (e.g. where, RegexWhere, replace). This allows the plugin to first create a file (if necessary) so that the data can be transmitted to it. The next call to the plugin will be a pluginIO command with a request to open the file write-only.</p>
<p>This call must return one of the following values:</p>
<pre><code> enum {
   CF_SKIP = 1,       /* skip file (not newer or something) */
   CF_ERROR,          /* error creating file */
   CF_EXTRACT,        /* file created, data to extract */
   CF_CREATED,        /* file created, no data to extract */
   CF_CORE            /* let bacula core handles the file creation */
};</code></pre>
<p>in the restore_pkt value <span><strong>create_status</strong></span>. For a normal file, unless there is an error, you must return <span><strong>CF_EXTRACT</strong></span>.</p>
<pre><code>struct restore_pkt {
   int32_t pkt_size;                  /* size of this packet */
   int32_t stream;                    /* attribute stream id */
   int32_t data_stream;               /* id of data stream to follow */
   int32_t type;                      /* file type FT */
   int32_t file_index;                /* file index */
   int32_t LinkFI;                    /* file index to data if hard link */
   uid_t uid;                         /* userid */
   struct stat statp;                 /* decoded stat packet */
   const char *attrEx;                /* extended attributes if any */
   const char *ofname;                /* output filename */
   const char *olname;                /* output link name */
   const char *where;                 /* where */
   const char *RegexWhere;            /* regex where */
   int replace;                       /* replace flag */
   int create_status;                 /* status from createFile() */
   int32_t pkt_end;                   /* end packet sentinel */

};</code></pre>
<p>Typical code to create a regular file would be the following:</p>
<pre><code>   struct plugin_ctx *p_ctx = (struct plugin_ctx *)ctx-&gt;pContext;
   time_t now = time(NULL);
   sp-&gt;fname = p_ctx-&gt;fname;   /* set the full path/filename I want to create */
   sp-&gt;type = FT_REG;
   sp-&gt;statp.st_mode = 0700 | S_IFREG;
   sp-&gt;statp.st_ctime = now;
   sp-&gt;statp.st_mtime = now;
   sp-&gt;statp.st_atime = now;
   sp-&gt;statp.st_size = -1;
   sp-&gt;statp.st_blksize = 4096;
   sp-&gt;statp.st_blocks = 1;
   return bRC_OK;</code></pre>
<p>This will create a virtual file. If you are creating a file that actually exists, you will most likely want to fill the statp packet using the stat() system call.</p>
<p>Creating a directory is similar, but requires a few extra steps:</p>
<pre><code>   struct plugin_ctx *p_ctx = (struct plugin_ctx *)ctx-&gt;pContext;
   time_t now = time(NULL);
   sp-&gt;fname = p_ctx-&gt;fname;   /* set the full path I want to create */
   sp-&gt;link = xxx; where xxx is p_ctx-&gt;fname with a trailing forward slash
   sp-&gt;type = FT_DIREND
   sp-&gt;statp.st_mode = 0700 | S_IFDIR;
   sp-&gt;statp.st_ctime = now;
   sp-&gt;statp.st_mtime = now;
   sp-&gt;statp.st_atime = now;
   sp-&gt;statp.st_size = -1;
   sp-&gt;statp.st_blksize = 4096;
   sp-&gt;statp.st_blocks = 1;
   return bRC_OK;</code></pre>
<p>The link field must be set with the full cononical path name, which always ends with a forward slash. If you do not terminate it with a forward slash, you will surely have problems later.</p>
<p>As with the example that creates a file, if you are backing up a real directory, you will want to do an stat() on the directory.</p>
<p>Note, if you want the directory permissions and times to be correctly restored, you must create the directory <span><strong>after</strong></span> all the file directories have been sent to Bacula. That allows the restore process to restore all the files in a directory using default directory options, then at the end, restore the directory permissions. If you do it the other way around, each time you restore a file, the OS will modify the time values for the directory entry.</p>
<h3 id="setfileattributesbpcontext-ctx-struct-restore_pkt-rp">setFileAttributes(bpContext *ctx, struct restore_pkt *rp)</h3>
<p>This is call not yet implemented. Called for a command plugin.</p>
<p>See the definition of <span><strong>restre_pkt</strong></span> in the above section.</p>
<h3 id="endrestorefilebpcontext-ctx">endRestoreFile(bpContext *ctx)</h3>
<p>Called when a command plugin is done restoring a file.</p>
<h3 id="pluginiobpcontext-ctx-struct-io_pkt-io">pluginIO(bpContext *ctx, struct io_pkt *io)</h3>
<p>Called to do the input (backup) or output (restore) of data from or to a file for a command plugin. These routines simulate the Unix read(), write(), open(), close(), and lseek() I/O calls, and the arguments are passed in the packet and the return values are also placed in the packet. In addition for Win32 systems the plugin must return two additional values (described below).</p>
<pre><code> enum {
   IO_OPEN = 1,
   IO_READ = 2,
   IO_WRITE = 3,
   IO_CLOSE = 4,
   IO_SEEK = 5
};

struct io_pkt {
   int32_t pkt_size;                  /* Size of this packet */
   int32_t func;                      /* Function code */
   int32_t count;                     /* read/write count */
   mode_t mode;                       /* permissions for created files */
   int32_t flags;                     /* Open flags */
   char *buf;                         /* read/write buffer */
   const char *fname;                 /* open filename */
   int32_t status;                    /* return status */
   int32_t io_errno;                  /* errno code */
   int32_t lerror;                    /* Win32 error code */
   int32_t whence;                    /* lseek argument */
   boffset_t offset;                  /* lseek argument */
   bool win32;                        /* Win32 GetLastError returned */
   int32_t pkt_end;                   /* end packet sentinel */
};</code></pre>
<p>The particular Unix function being simulated is indicated by the <span><strong>func</strong></span>, which will have one of the IO_OPEN, IO_READ, … codes listed above. The status code that would be returned from a Unix call is returned in <span><strong>status</strong></span> for IO_OPEN, IO_CLOSE, IO_READ, and IO_WRITE. The return value for IO_SEEK is returned in <span><strong>offset</strong></span> which in general is a 64 bit value.</p>
<p>When there is an error on Unix systems, you must always set io_error, and on a Win32 system, you must always set win32, and the returned value from the OS call GetLastError() in lerror.</p>
<p>For all except IO_SEEK, <span><strong>status</strong></span> is the return result. In general it is a positive integer unless there is an error in which case it is -1.</p>
<p>The following describes each call and what you get and what you should return:</p>
<dl>
<dt>IO_OPEN</dt>
<dd><p>You will be passed fname, mode, and flags. You must set on return: status, and if there is a Unix error io_errno must be set to the errno value, and if there is a Win32 error win32 and lerror.</p>
</dd>
<dt>IO_READ</dt>
<dd><p>You will be passed: count, and buf (buffer of size count). You must set on return: status to the number of bytes read into the buffer (buf) or -1 on an error, and if there is a Unix error io_errno must be set to the errno value, and if there is a Win32 error, win32 and lerror must be set.</p>
</dd>
<dt>IO_WRITE</dt>
<dd><p>You will be passed: count, and buf (buffer of size count). You must set on return: status to the number of bytes written from the buffer (buf) or -1 on an error, and if there is a Unix error io_errno must be set to the errno value, and if there is a Win32 error, win32 and lerror must be set.</p>
</dd>
<dt>IO_CLOSE</dt>
<dd><p>Nothing will be passed to you. On return you must set status to 0 on success and -1 on failure. If there is a Unix error io_errno must be set to the errno value, and if there is a Win32 error, win32 and lerror must be set.</p>
</dd>
<dt>IO_LSEEK</dt>
<dd><p>You will be passed: offset, and whence. offset is a 64 bit value and is the position to seek to relative to whence. whence is one of the following SEEK_SET, SEEK_CUR, or SEEK_END indicating to either to seek to an absolute possition, relative to the current position or relative to the end of the file. You must pass back in offset the absolute location to which you seeked. If there is an error, offset should be set to -1. If there is a Unix error io_errno must be set to the errno value, and if there is a Win32 error, win32 and lerror must be set.</p>
<p>Note: Bacula will call IO_SEEK only when writing a sparse file.</p>
</dd>
</dl>
<h3 id="bool-checkfilebpcontext-ctx-char-fname">bool checkFile(bpContext *ctx, char *fname)</h3>
<p>If this entry point is set, Bacula will call it after backing up all file data during an Accurate backup. It will be passed the full filename for each file that Bacula is proposing to mark as deleted. Only files previously backed up but not backed up in the current session will be marked to be deleted. If you return <span><strong>false</strong></span>, the file will be be marked deleted. If you return <span><strong>true</strong></span> the file will not be marked deleted. This permits a plugin to ensure that previously saved virtual files or files controlled by your plugin that have not change (not backed up in the current job) are not marked to be deleted. This entry point will only be called during Accurate Incrmental and Differential backup jobs.</p>
<h2 id="bacula-plugin-entrypoints">Bacula Plugin Entrypoints</h2>
<p>When Bacula calls one of your plugin entrypoints, you can call back to the entrypoints in Bacula that were supplied during the xxx plugin call to get or set information within Bacula.</p>
<h3 id="brc-registerbaculaeventsbpcontext-ctx">bRC registerBaculaEvents(bpContext *ctx, …)</h3>
<p>This Bacula entrypoint will allow you to register to receive events that are not autmatically passed to your plugin by default. This entrypoint currently is unimplemented.</p>
<h3 id="brc-getbaculavaluebpcontext-ctx-bvariable-var-void-value">bRC getBaculaValue(bpContext *ctx, bVariable var, void *value)</h3>
<p>Calling this entrypoint, you can obtain specific values that are available in Bacula. The following Variables can be referenced:</p>
<ul>
<li><p>bVarJobId returns an int</p></li>
<li><p>bVarFDName returns a char *</p></li>
<li><p>bVarLevel returns an int</p></li>
<li><p>bVarClient returns a char *</p></li>
<li><p>bVarJobName returns a char *</p></li>
<li><p>bVarJobStatus returns an int</p></li>
<li><p>bVarSinceTime returns an int (time_t)</p></li>
<li><p>bVarAccurate returns an int</p></li>
</ul>
<h3 id="brc-setbaculavaluebpcontext-ctx-bvariable-var-void-value">bRC setBaculaValue(bpContext *ctx, bVariable var, void *value)</h3>
<p>Calling this entrypoint allows you to set particular values in Bacula. The only variable that can currently be set is <span><strong>bVarFileSeen</strong></span> and the value passed is a char * that points to the full filename for a file that you are indicating has been seen and hence is not deleted.</p>
<h3 id="brc-jobmessagebpcontext-ctx-const-char-file-int-line-int-type-utime_t-mtime-const-char-fmt">bRC JobMessage(bpContext *ctx, const char *file, int line, int type, utime_t mtime, const char *fmt, …)</h3>
<p>This call permits you to put a message in the Job Report.</p>
<h3 id="brc-debugmessagebpcontext-ctx-const-char-file-int-line-int-level-const-char-fmt">bRC DebugMessage(bpContext *ctx, const char *file, int line, int level, const char *fmt, …)</h3>
<p>This call permits you to print a debug message.</p>
<h3 id="void-baculamallocbpcontext-ctx-const-char-file-int-line-size_t-size">void baculaMalloc(bpContext *ctx, const char *file, int line, size_t size)</h3>
<p>This call permits you to obtain memory from Bacula’s memory allocator.</p>
<h3 id="void-baculafreebpcontext-ctx-const-char-file-int-line-void-mem">void baculaFree(bpContext *ctx, const char *file, int line, void *mem)</h3>
<p>This call permits you to free memory obtained from Bacula’s memory allocator.</p>
<h2 id="building-bacula-plugins">Building Bacula Plugins</h2>
<p>There is currently one sample program <span><strong>example-plugin-fd.c</strong></span> and one working plugin <span><strong>bpipe-fd.c</strong></span> that can be found in the Bacula <span><strong>src/plugins/fd</strong></span> directory. Both are built with the following:</p>
<pre><code> cd &lt;bacula-source&gt;
 ./configure &lt;your-options&gt;
 make
 ...
 cd src/plugins/fd
 make
 make test</code></pre>
<p>After building Bacula and changing into the src/plugins/fd directory, the <span><strong>make</strong></span> command will build the <span><strong>bpipe-fd.so</strong></span> plugin, which is a very useful and working program.</p>
<p>The <span><strong>make test</strong></span> command will build the <span><strong>example-plugin-fd.so</strong></span> plugin and a binary named <span><strong>main</strong></span>, which is build from the source code located in <span><strong>src/filed/fd_plugins.c</strong></span>.</p>
<p>If you execute <span><strong>./main</strong></span>, it will load and run the example-plugin-fd plugin simulating a small number of the calling sequences that Bacula uses in calling a real plugin. This allows you to do initial testing of your plugin prior to trying it with Bacula.</p>
<p>You can get a good idea of how to write your own plugin by first studying the example-plugin-fd, and actually running it. Then it can also be instructive to read the bpipe-fd.c code as it is a real plugin, which is still rather simple and small.</p>
<p>When actually writing your own plugin, you may use the example-plugin-fd.c code as a template for your code.</p>
<p>Platform Support {#_PlatformChapter} ================</p>
<h2 id="general">General</h2>
<p>This chapter describes the requirements for having a supported platform (Operating System). In general, Bacula is quite portable. It supports 32 and 64 bit architectures as well as bigendian and littleendian machines. For full support, the platform (Operating System) must implement POSIX Unix system calls. However, for File daemon support only, a small compatibility library can be written to support almost any architecture.</p>
<p>Currently Linux, FreeBSD, and Solaris are fully supported platforms, which means that the code has been tested on those machines and passes a full set of regression tests.</p>
<p>In addition, the Windows File daemon is supported on most versions of Windows, and finally, there are a number of other platforms where the File daemon (client) is known to run: NetBSD, OpenBSD, Mac OSX, SGI, …</p>
<h2 id="requirements-to-become-a-supported-platform">Requirements to become a Supported Platform</h2>
<p>As mentioned above, in order to become a fully supported platform, it must support POSIX Unix system calls. In addition, the following requirements must be met:</p>
<ul>
<li><p>The principal developer (currently Kern) must have non-root ssh access to a test machine running the platform.</p></li>
<li><p>The ideal requirements and minimum requirements for this machine are given below.</p></li>
<li><p>There must be a defined platform champion who is normally a system administrator for the machine that is available. This person need not be a developer/programmer but must be familiar with system administration of the platform.</p></li>
<li><p>There must be at least one person designated who will run regression tests prior to each release. Releases occur approximately once every 6 months, but can be more frequent. It takes at most a day’s effort to setup the regression scripts in the beginning, and after that, they can either be run daily or on demand before a release. Running the regression scripts involves only one or two command line commands and is fully automated.</p></li>
<li><p>Ideally there are one or more persons who will package each Bacula release.</p></li>
<li><p>Ideally there are one or more developers who can respond to and fix platform specific bugs.</p></li>
</ul>
<p>Ideal requirements for a test machine:</p>
<ul>
<li><p>The principal developer will have non-root ssh access to the test machine at all times.</p></li>
<li><p>The pricipal developer will have a root password.</p></li>
<li><p>The test machine will provide approximately 200 MB of disk space for continual use.</p></li>
<li><p>The test machine will have approximately 500 MB of free disk space for temporary use.</p></li>
<li><p>The test machine will run the most common version of the OS.</p></li>
<li><p>The test machine will have an autochanger of DDS-4 technology or later having two or more tapes.</p></li>
<li><p>The test machine will have MySQL and/or PostgreSQL database access for account “bacula” available.</p></li>
<li><p>The test machine will have sftp access.</p></li>
<li><p>The test machine will provide an smtp server.</p></li>
</ul>
<p>Minimum requirements for a test machine:</p>
<ul>
<li><p>The principal developer will have non-root ssh access to the test machine when requested approximately once a month.</p></li>
<li><p>The pricipal developer not have root access.</p></li>
<li><p>The test machine will provide approximately 80 MB of disk space for continual use.</p></li>
<li><p>The test machine will have approximately 300 MB of free disk space for temporary use.</p></li>
<li><p>The test machine will run the the OS.</p></li>
<li><p>The test machine will have a tape drive of DDS-4 technology or later that can be scheduled for access.</p></li>
<li><p>The test machine will not have MySQL and/or PostgreSQL database access.</p></li>
<li><p>The test machine will have no sftp access.</p></li>
<li><p>The test machine will provide no email access.</p></li>
</ul>
<p>Bare bones test machine requirements:</p>
<ul>
<li><p>The test machine is available only to a designated test person (your own machine).</p></li>
<li><p>The designated test person runs the regession tests on demand.</p></li>
<li><p>The test machine has a tape drive available.</p></li>
</ul>
<p>Daemon Protocol {#_ChapterStart2} ===============</p>
<h2 id="general-1">General</h2>
<p>This document describes the protocols used between the various daemons. As Bacula has developed, it has become quite out of date. The general idea still holds true, but the details of the fields for each command, and indeed the commands themselves have changed considerably.</p>
<p>It is intended to be a technical discussion of the general daemon protocols and as such is not targeted at end users but rather at developers and system administrators that want or need to know more of the working details of <span><strong>Bacula</strong></span>.</p>
<h2 id="low-level-network-protocol">Low Level Network Protocol</h2>
<p>At the lowest level, the network protocol is handled by <span><strong>BSOCK</strong></span> packets which contain a lot of information about the status of the network connection: who is at the other end, etc. Each basic <span><strong>Bacula</strong></span> network read or write actually consists of two low level network read/writes. The first write always sends four bytes of data in machine independent byte order. If data is to follow, the first four bytes are a positive non-zero integer indicating the length of the data that follow in the subsequent write. If the four byte integer is zero or negative, it indicates a special request, a sort of network signaling capability. In this case, no data packet will follow. The low level BSOCK routines expect that only a single thread is accessing the socket at a time. It is advised that multiple threads do not read/write the same socket. If you must do this, you must provide some sort of locking mechanism. It would not be appropriate for efficiency reasons to make every call to the BSOCK routines lock and unlock the packet.</p>
<h2 id="general-daemon-protocol">General Daemon Protocol</h2>
<p>In general, all the daemons follow the following global rules. There may be exceptions depending on the specific case. Normally, one daemon will be sending commands to another daemon (specifically, the Director to the Storage daemon and the Director to the File daemon).</p>
<ul>
<li><p>Commands are always ASCII commands that are upper/lower case dependent as well as space sensitive.</p></li>
<li><p>All binary data is converted into ASCII (either with printf statements or using base64 encoding).</p></li>
<li><p>All responses to commands sent are always prefixed with a return numeric code where codes in the 1000’s are reserved for the Director, the 2000’s are reserved for the File daemon, and the 3000’s are reserved for the Storage daemon.</p></li>
<li><p>Any response that is not prefixed with a numeric code is a command (or subcommand if you like) coming from the other end. For example, while the Director is corresponding with the Storage daemon, the Storage daemon can request Catalog services from the Director. This convention permits each side to send commands to the other daemon while simultaneously responding to commands.</p></li>
<li><p>Any response that is of zero length, depending on the context, either terminates the data stream being sent or terminates command mode prior to closing the connection.</p></li>
<li><p>Any response that is of negative length is a special sign that normally requires a response. For example, during data transfer from the File daemon to the Storage daemon, normally the File daemon sends continuously without intervening reads. However, periodically, the File daemon will send a packet of length -1 indicating that the current data stream is complete and that the Storage daemon should respond to the packet with an OK, ABORT JOB, PAUSE, etc. This permits the File daemon to efficiently send data while at the same time occasionally “polling” the Storage daemon for his status or any special requests.</p>
<p>Currently, these negative lengths are specific to the daemon, but shortly, the range 0 to -999 will be standard daemon wide signals, while -1000 to -1999 will be for Director user, -2000 to -2999 for the File daemon, and -3000 to -3999 for the Storage daemon.</p></li>
</ul>
<h2 id="the-protocol-used-between-the-director-and-the-storage-daemon">The Protocol Used Between the Director and the Storage Daemon</h2>
<p>Before sending commands to the File daemon, the Director opens a Message channel with the Storage daemon, identifies itself and presents its password. If the password check is OK, the Storage daemon accepts the Director. The Director then passes the Storage daemon, the JobId to be run as well as the File daemon authorization (append, read all, or read for a specific session). The Storage daemon will then pass back to the Director a enabling key for this JobId that must be presented by the File daemon when opening the job. Until this process is complete, the Storage daemon is not available for use by File daemons.</p>
<pre><code>SD: listens
DR: makes connection
DR: Hello &lt;Director-name&gt; calling &lt;password&gt;
SD: 3000 OK Hello
DR: JobId=nnn Allow=(append, read) Session=(*, SessionId)
                    (Session not implemented yet)
SD: 3000 OK Job Authorization=&lt;password&gt;
DR: use device=&lt;device-name&gt; media_type=&lt;media-type&gt;
        pool_name=&lt;pool-name&gt; pool_type=&lt;pool_type&gt;
SD: 3000 OK use device</code></pre>
<p>For the Director to be authorized, the <span>&lt;</span>Director-name<span>&gt;</span> and the <span>&lt;</span>password<span>&gt;</span> must match the values in one of the Storage daemon’s Director resources (there may be several Directors that can access a single Storage daemon).</p>
<h2 id="the-protocol-used-between-the-director-and-the-file-daemon">The Protocol Used Between the Director and the File Daemon</h2>
<p>A typical conversation might look like the following:</p>
<pre><code>FD: listens
DR: makes connection
DR: Hello &lt;Director-name&gt; calling &lt;password&gt;
FD: 2000 OK Hello
DR: JobId=nnn Authorization=&lt;password&gt;
FD: 2000 OK Job
DR: storage address = &lt;Storage daemon address&gt; port = &lt;port-number&gt;
          name = &lt;DeviceName&gt; mediatype = &lt;MediaType&gt;
FD: 2000 OK storage
DR: include
DR: &lt;directory1&gt;
DR: &lt;directory2&gt;
    ...
DR: Null packet
FD: 2000 OK include
DR: exclude
DR: &lt;directory1&gt;
DR: &lt;directory2&gt;
    ...
DR: Null packet
FD: 2000 OK exclude
DR: full
FD: 2000 OK full
DR: save
FD: 2000 OK save
FD: Attribute record for each file as sent to the
    Storage daemon (described above).
FD: Null packet
FD: &lt;append close responses from Storage daemon&gt;
    e.g.
    3000 OK Volumes = &lt;number of volumes&gt;
    3001 Volume = &lt;volume-id&gt; &lt;start file&gt; &lt;start block&gt;
         &lt;end file&gt; &lt;end block&gt; &lt;volume session-id&gt;
    3002 Volume data = &lt;date/time of last write&gt; &lt;Number bytes written&gt;
         &lt;number errors&gt;
    ... additional Volume / Volume data pairs for volumes 2 .. n
FD: Null packet
FD: close socket</code></pre>
<h2 id="the-save-protocol-between-the-file-daemon-and-the-storage-daemon">The Save Protocol Between the File Daemon and the Storage Daemon</h2>
<p>Once the Director has send a <span><strong>save</strong></span> command to the File daemon, the File daemon will contact the Storage daemon to begin the save.</p>
<p>In what follows: FD: refers to information set via the network from the File daemon to the Storage daemon, and SD: refers to information set from the Storage daemon to the File daemon.</p>
<h3 id="command-and-control-information">Command and Control Information</h3>
<p>Command and control information is exchanged in human readable ASCII commands.</p>
<pre><code>FD: listens
SD: makes connection
FD: append open session = &lt;JobId&gt; [&lt;password&gt;]
SD: 3000 OK ticket = &lt;number&gt;
FD: append data &lt;ticket-number&gt;
SD: 3000 OK data address = &lt;IPaddress&gt; port = &lt;port&gt;</code></pre>
<h3 id="data-information">Data Information</h3>
<p>The Data information consists of the file attributes and data to the Storage daemon. For the most part, the data information is sent one way: from the File daemon to the Storage daemon. This allows the File daemon to transfer information as fast as possible without a lot of handshaking and network overhead.</p>
<p>However, from time to time, the File daemon needs to do a sort of checkpoint of the situation to ensure that everything is going well with the Storage daemon. To do so, the File daemon sends a packet with a negative length indicating that he wishes the Storage daemon to respond by sending a packet of information to the File daemon. The File daemon then waits to receive a packet from the Storage daemon before continuing.</p>
<p>All data sent are in binary format except for the header packet, which is in ASCII. There are two packet types used data transfer mode: a header packet, the contents of which are known to the Storage daemon, and a data packet, the contents of which are never examined by the Storage daemon.</p>
<p>The first data packet to the Storage daemon will be an ASCII header packet consisting of the following data.</p>
<p><span>&lt;</span>File-Index<span>&gt;</span> <span>&lt;</span>Stream-Id<span>&gt;</span> <span>&lt;</span>Info<span>&gt;</span> where <span><strong><span>&lt;</span>File-Index<span>&gt;</span></strong></span> is a sequential number beginning from one that increments with each file (or directory) sent.</p>
<p>where <span><strong><span>&lt;</span>Stream-Id<span>&gt;</span></strong></span> will be 1 for the Attributes record and 2 for uncompressed File data. 3 is reserved for the MD5 signature for the file.</p>
<p>where <span><strong><span>&lt;</span>Info<span>&gt;</span></strong></span> transmit information about the Stream to the Storage Daemon. It is a character string field where each character has a meaning. The only character currently defined is 0 (zero), which is simply a place holder (a no op). In the future, there may be codes indicating compressed data, encrypted data, etc.</p>
<p>Immediately following the header packet, the Storage daemon will expect any number of data packets. The series of data packets is terminated by a zero length packet, which indicates to the Storage daemon that the next packet will be another header packet. As previously mentioned, a negative length packet is a request for the Storage daemon to temporarily enter command mode and send a reply to the File daemon. Thus an actual conversation might contain the following exchanges:</p>
<pre><code>FD: &lt;1 1 0&gt; (header packet)
FD: &lt;data packet containing file-attributes&gt;
FD: Null packet
FD: &lt;1 2 0&gt;
FD: &lt;multiple data packets containing the file data&gt;
FD: Packet length = -1
SD: 3000 OK
FD: &lt;2 1 0&gt;
FD: &lt;data packet containing file-attributes&gt;
FD: Null packet
FD: &lt;2 2 0&gt;
FD: &lt;multiple data packets containing the file data&gt;
FD: Null packet
FD: Null packet
FD: append end session &lt;ticket-number&gt;
SD: 3000 OK end
FD: append close session &lt;ticket-number&gt;
SD: 3000 OK Volumes = &lt;number of volumes&gt;
SD: 3001 Volume = &lt;volumeid&gt; &lt;start file&gt; &lt;start block&gt;
     &lt;end file&gt; &lt;end block&gt; &lt;volume session-id&gt;
SD: 3002 Volume data = &lt;date/time of last write&gt; &lt;Number bytes written&gt;
     &lt;number errors&gt;
SD: ... additional Volume / Volume data pairs for
     volumes 2 .. n
FD: close socket</code></pre>
<p>The information returned to the File daemon by the Storage daemon in response to the <span><strong>append close session</strong></span> is transmit in turn to the Director.</p>
<p>Director Services Daemon {#_ChapterStart6} ========================</p>
<p>This chapter is intended to be a technical discussion of the Director services and as such is not targeted at end users but rather at developers and system administrators that want or need to know more of the working details of <span><strong>Bacula</strong></span>.</p>
<p>The <span><strong>Bacula Director</strong></span> services consist of the program that supervises all the backup and restore operations.</p>
<p>To be written …</p>
<p>File Services Daemon {#_ChapterStart11} ====================</p>
<p>Please note, this section is somewhat out of date as the code has evolved significantly. The basic idea has not changed though.</p>
<p>This chapter is intended to be a technical discussion of the File daemon services and as such is not targeted at end users but rather at developers and system administrators that want or need to know more of the working details of <span><strong>Bacula</strong></span>.</p>
<p>The <span><strong>Bacula File Services</strong></span> consist of the programs that run on the system to be backed up and provide the interface between the Host File system and Bacula – in particular, the Director and the Storage services.</p>
<p>When time comes for a backup, the Director gets in touch with the File daemon on the client machine and hands it a set of “marching orders” which, if written in English, might be something like the following:</p>
<p>OK, <span><strong>File daemon</strong></span>, it’s time for your daily incremental backup. I want you to get in touch with the Storage daemon on host archive.mysite.com and perform the following save operations with the designated options. You’ll note that I’ve attached include and exclude lists and patterns you should apply when backing up the file system. As this is an incremental backup, you should save only files modified since the time you started your last backup which, as you may recall, was 2000-11-19-06:43:38. Please let me know when you’re done and how it went. Thank you.</p>
<p>So, having been handed everything it needs to decide what to dump and where to store it, the File daemon doesn’t need to have any further contact with the Director until the backup is complete providing there are no errors. If there are errors, the error messages will be delivered immediately to the Director. While the backup is proceeding, the File daemon will send the file coordinates and data for each file being backed up to the Storage daemon, which will in turn pass the file coordinates to the Director to put in the catalog.</p>
<p>During a <span><strong>Verify</strong></span> of the catalog, the situation is different, since the File daemon will have an exchange with the Director for each file, and will not contact the Storage daemon.</p>
<p>A <span><strong>Restore</strong></span> operation will be very similar to the <span><strong>Backup</strong></span> except that during the <span><strong>Restore</strong></span> the Storage daemon will not send storage coordinates to the Director since the Director presumably already has them. On the other hand, any error messages from either the Storage daemon or File daemon will normally be sent directly to the Directory (this, of course, depends on how the Message resource is defined).</p>
<h2 id="commands-received-from-the-director-for-a-backup">Commands Received from the Director for a Backup</h2>
<p>To be written …</p>
<h2 id="commands-received-from-the-director-for-a-restore">Commands Received from the Director for a Restore</h2>
<p>To be written …</p>
<p>Storage Daemon Design {#_ChapterStart3} =====================</p>
<p>This chapter is intended to be a technical discussion of the Storage daemon services and as such is not targeted at end users but rather at developers and system administrators that want or need to know more of the working details of <span><strong>Bacula</strong></span>.</p>
<p>This document is somewhat out of date.</p>
<h2 id="sd-design-introduction">SD Design Introduction</h2>
<p>The Bacula Storage daemon provides storage resources to a Bacula installation. An individual Storage daemon is associated with a physical permanent storage device (for example, a tape drive, CD writer, tape changer or jukebox, etc.), and may employ auxiliary storage resources (such as space on a hard disk file system) to increase performance and/or optimize use of the permanent storage medium.</p>
<p>Any number of storage daemons may be run on a given machine; each associated with an individual storage device connected to it, and BACULA operations may employ storage daemons on any number of hosts connected by a network, local or remote. The ability to employ remote storage daemons (with appropriate security measures) permits automatic off-site backup, possibly to publicly available backup repositories.</p>
<h2 id="sd-development-outline">SD Development Outline</h2>
<p>In order to provide a high performance backup and restore solution that scales to very large capacity devices and networks, the storage daemon must be able to extract as much performance from the storage device and network with which it interacts. In order to accomplish this, storage daemons will eventually have to sacrifice simplicity and painless portability in favor of techniques which improve performance. My goal in designing the storage daemon protocol and developing the initial prototype storage daemon is to provide for these additions in the future, while implementing an initial storage daemon which is very simple and portable to almost any POSIX-like environment. This original storage daemon (and its evolved descendants) can serve as a portable solution for non-demanding backup requirements (such as single servers of modest size, individual machines, or small local networks), while serving as the starting point for development of higher performance configurable derivatives which use techniques such as POSIX threads, shared memory, asynchronous I/O, buffering to high-speed intermediate media, and support for tape changers and jukeboxes.</p>
<h2 id="sd-connections-and-sessions">SD Connections and Sessions</h2>
<p>A client connects to a storage server by initiating a conventional TCP connection. The storage server accepts the connection unless its maximum number of connections has been reached or the specified host is not granted access to the storage server. Once a connection has been opened, the client may make any number of Query requests, and/or initiate (if permitted), one or more Append sessions (which transmit data to be stored by the storage daemon) and/or Read sessions (which retrieve data from the storage daemon).</p>
<p>Most requests and replies sent across the connection are simple ASCII strings, with status replies prefixed by a four digit status code for easier parsing. Binary data appear in blocks stored and retrieved from the storage. Any request may result in a single-line status reply of “<span>3201 Notificationpending</span>”, which indicates the client must send a “Query notification” request to retrieve one or more notifications posted to it. Once the notifications have been returned, the client may then resubmit the request which resulted in the 3201 status.</p>
<p>The following descriptions omit common error codes, yet to be defined, which can occur from most or many requests due to events like media errors, restarting of the storage daemon, etc. These details will be filled in, along with a comprehensive list of status codes along with which requests can produce them in an update to this document.</p>
<h3 id="sd-append-requests">SD Append Requests</h3>
<dl>
<dt><span>append open session = <span>&lt;</span>JobId<span>&gt;</span> [ <span>&lt;</span>Password<span>&gt;</span> ] </span></dt>
<dd><p>A data append session is opened with the Job ID given by <span><em>JobId</em></span> with client password (if required) given by <span><em>Password</em></span>. If the session is successfully opened, a status of <span>3000 OK</span> is returned with a “<span>ticket = </span><span><em>number</em></span>” reply used to identify subsequent messages in the session. If too many sessions are open, or a conflicting session (for example, a read in progress when simultaneous read and append sessions are not permitted), a status of “<span>3502 Volume busy</span>” is returned. If no volume is mounted, or the volume mounted cannot be appended to, a status of “<span>3503 Volume not mounted</span>” is returned.</p>
</dd>
<dt>append data = <span>&lt;</span>ticket-number<span>&gt;</span></dt>
<dd><p>If the append data is accepted, a status of <span>3000 OK data address = <span>&lt;</span>IPaddress<span>&gt;</span> port = <span>&lt;</span>port<span>&gt;</span></span> is returned, where the <span>IPaddress</span> and <span>port</span> specify the IP address and port number of the data channel. Error status codes are <span>3504 Invalid ticket number</span> and <span>3505 Session aborted</span>, the latter of which indicates the entire append session has failed due to a daemon or media error.</p>
<p>Once the File daemon has established the connection to the data channel opened by the Storage daemon, it will transfer a header packet followed by any number of data packets. The header packet is of the form:</p>
<p><span>file-index<span>&gt;</span> <span>&lt;</span>stream-id<span>&gt;</span> <span>&lt;</span>info<span>&gt;</span></span></p>
<p>The details are specified in the section of this document.</p>
</dd>
<dt>*append abort session = <span>&lt;</span>ticket-number<span>&gt;</span></dt>
<dd><p>The open append session with ticket <span><em>ticket-number</em></span> is aborted; any blocks not yet written to permanent media are discarded. Subsequent attempts to append data to the session will receive an error status of <span>3505Session aborted</span>.</p>
</dd>
<dt>append end session = <span>&lt;</span>ticket-number<span>&gt;</span></dt>
<dd><p>The open append session with ticket <span><em>ticket-number</em></span> is marked complete; no further blocks may be appended. The storage daemon will give priority to saving any buffered blocks from this session to permanent media as soon as possible.</p>
</dd>
<dt>append close session = <span>&lt;</span>ticket-number<span>&gt;</span></dt>
<dd><p>The append session with ticket <span><em>ticket</em></span> is closed. This message does not receive an <span>3000 OK</span> reply until all of the content of the session are stored on permanent media, at which time said reply is given, followed by a list of volumes, from first to last, which contain blocks from the session, along with the first and last file and block on each containing session data and the volume session key identifying data from that session in lines with the following format:</p>
<p><span>Volume-id<span>&gt;</span> <span>&lt;</span>start-file<span>&gt;</span> <span>&lt;</span>start-block<span>&gt;</span> <span>&lt;</span>end-file<span>&gt;</span> <span>&lt;</span>end-block<span>&gt;</span> <span>&lt;</span>volume-session-id<span>&gt;</span></span>where <span><em>Volume-id</em></span> is the volume label, <span><em>start-file</em></span> and <span><em>start-block</em></span> are the file and block containing the first data from that session on the volume, <span><em>end-file</em></span> and <span><em>end-block</em></span> are the file and block with the last data from the session on the volume and <span><em>volume-session-id</em></span> is the volume session ID for blocks from the session stored on that volume.</p>
</dd>
</dl>
<h3 id="sd-read-requests">SD Read Requests</h3>
<dl>
<dt>Read open session = <span>&lt;</span>JobId<span>&gt;</span> <span>&lt;</span>Volume-id<span>&gt;</span> <span>&lt;</span>start-file<span>&gt;</span> <span>&lt;</span>start-block<span>&gt;</span> <span>&lt;</span>end-file<span>&gt;</span> <span>&lt;</span>end-block<span>&gt;</span> <span>&lt;</span>volume-session-id<span>&gt;</span> <span>&lt;</span>password<span>&gt;</span></dt>
<dd><p>where <span><em>Volume-id</em></span> is the volume label, <span><em>start-file</em></span> and <span><em>start-block</em></span> are the file and block containing the first data from that session on the volume, <span><em>end-file</em></span> and <span><em>end-block</em></span> are the file and block with the last data from the session on the volume and <span><em>volume-session-id</em></span> is the volume session ID for blocks from the session stored on that volume.</p>
<p>If the session is successfully opened, a status of</p>
<p><span>``</span></p>
<p>is returned with a reply used to identify subsequent messages in the session. If too many sessions are open, or a conflicting session (for example, an append in progress when simultaneous read and append sessions are not permitted), a status of ”<span>3502 Volume busy</span>“ is returned. If no volume is mounted, or the volume mounted cannot be appended to, a status of ”<span>3503 Volume not mounted</span>“ is returned. If no block with the given volume session ID and the correct client ID number appears in the given first file and block for the volume, a status of ”<span>3505 Session notfound</span>`` is returned.</p>
</dd>
<dt>Read data = <span>&lt;</span>Ticket<span>&gt;</span> <span>&gt;</span> <span>&lt;</span>Block<span>&gt;</span></dt>
<dd><p>The specified Block of data from open read session with the specified Ticket number is returned, with a status of <span>3000 OK</span> followed by a ”<span>Length = </span><span><em>size</em></span>“ line giving the length in bytes of the block data which immediately follows. Blocks must be retrieved in ascending order, but blocks may be skipped. If a block number greater than the largest stored on the volume is requested, a status of ”<span>3201 End of volume</span>“ is returned. If a block number greater than the largest in the file is requested, a status of ”<span>3401 End of file</span>`` is returned.</p>
</dd>
<dt>Read close session = <span>&lt;</span>Ticket<span>&gt;</span></dt>
<dd><p>The read session with Ticket number is closed. A read session may be closed at any time; you needn’t read all its blocks before closing it.</p>
</dd>
</dl>
<p><span><em>by January 30th, MM </em></span></p>
<h2 id="sd-data-structures">SD Data Structures</h2>
<p>In the Storage daemon, there is a Device resource (i.e. from conf file) that describes each physical device. When the physical device is used it is controled by the DEVICE structure (defined in dev.h), and typically refered to as dev in the C++ code. Anyone writing or reading a physical device must ultimately get a lock on the DEVICE structure – this controls the device. However, multiple Jobs (defined by a JCR structure src/jcr.h) can be writing a physical DEVICE at the same time (of course they are sequenced by locking the DEVICE structure). There are a lot of job dependent “device” variables that may be different for each Job such as spooling (one job may spool and another may not, and when a job is spooling, it must have an i/o packet open, each job has its own record and block structures, …), so there is a device control record or DCR that is the primary way of interfacing to the physical device. The DCR contains all the job specific data as well as a pointer to the Device resource (DEVRES structure) and the physical DEVICE structure.</p>
<p>Now if a job is writing to two devices (it could be writing two separate streams to the same device), it must have two DCRs. Today, the code only permits one. This won’t be hard to change, but it is new code.</p>
<p>Today three jobs (threads), two physical devices each job writes to only one device:</p>
<pre><code>  Job1 -&gt; DCR1 -&gt; DEVICE1
  Job2 -&gt; DCR2 -&gt; DEVICE1
  Job3 -&gt; DCR3 -&gt; DEVICE2</code></pre>
<p>To be implemented three jobs, three physical devices, but job1 is writing simultaneously to three devices:</p>
<pre><code>  Job1 -&gt; DCR1 -&gt; DEVICE1
          -&gt; DCR4 -&gt; DEVICE2
          -&gt; DCR5 -&gt; DEVICE3
  Job2 -&gt; DCR2 -&gt; DEVICE1
  Job3 -&gt; DCR3 -&gt; DEVICE2

  Job = job control record
  DCR = Job contorl data for a specific device
  DEVICE = Device only control data</code></pre>
<p>Catalog Services {#_ChapterStart30} ================</p>
<h2 id="general-2">General</h2>
<p>This chapter is intended to be a technical discussion of the Catalog services and as such is not targeted at end users but rather at developers and system administrators that want or need to know more of the working details of <span><strong>Bacula</strong></span>.</p>
<p>The <span><strong>Bacula Catalog</strong></span> services consist of the programs that provide the SQL database engine for storage and retrieval of all information concerning files that were backed up and their locations on the storage media.</p>
<p>We have investigated the possibility of using the following SQL engines for Bacula: Beagle, mSQL, GNU SQL, PostgreSQL, SQLite, Oracle, and MySQL. Each presents certain problems with either licensing or maturity. At present, we have chosen for development purposes to use MySQL, PostgreSQL and SQLite. MySQL was chosen because it is fast, proven to be reliable, widely used, and actively being developed. MySQL is released under the GNU GPL license. PostgreSQL was chosen because it is a full-featured, very mature database, and because Dan Langille did the Bacula driver for it. PostgreSQL is distributed under the BSD license. SQLite was chosen because it is small, efficient, and can be directly embedded in <span><strong>Bacula</strong></span> thus requiring much less effort from the system administrator or person building <span><strong>Bacula</strong></span>. In our testing SQLite has performed very well, and for the functions that we use, it has never encountered any errors except that it does not appear to handle databases larger than 2GBytes. That said, we would not recommend it for serious production use.</p>
<p>The Bacula SQL code has been written in a manner that will allow it to be easily modified to support any of the current SQL database systems on the market (for example: mSQL, iODBC, unixODBC, Solid, OpenLink ODBC, EasySoft ODBC, InterBase, Oracle8, Oracle7, and DB2).</p>
<p>If you do not specify either <span><strong><code>--</code>with-mysql</strong></span> or <span><strong><code>--</code>with-postgresql</strong></span> or <span><strong><code>--</code>with-sqlite</strong></span> on the ./configure line, Bacula will use its minimalist internal database. This database is kept for build reasons but is no longer supported. Bacula <span><strong>requires</strong></span> one of the three databases (MySQL, PostgreSQL, or SQLite) to run.</p>
<h3 id="filenames-and-maximum-filename-length">Filenames and Maximum Filename Length</h3>
<p>In general, either MySQL, PostgreSQL or SQLite permit storing arbitrary long path names and file names in the catalog database. In practice, there still may be one or two places in the Catalog interface code that restrict the maximum path length to 512 characters and the maximum file name length to 512 characters. These restrictions are believed to have been removed. Please note, these restrictions apply only to the Catalog database and thus to your ability to list online the files saved during any job. All information received and stored by the Storage daemon (normally on tape) allows and handles arbitrarily long path and filenames.</p>
<h3 id="installing-and-configuring-mysql">Installing and Configuring MySQL</h3>
<p>For the details of installing and configuring MySQL, please see the chapter of this manual.</p>
<h3 id="installing-and-configuring-postgresql">Installing and Configuring PostgreSQL</h3>
<p>For the details of installing and configuring PostgreSQL, please see the chapter of this manual.</p>
<h3 id="installing-and-configuring-sqlite">Installing and Configuring SQLite</h3>
<p>For the details of installing and configuring SQLite, please see the chapter of this manual.</p>
<h3 id="internal-bacula-catalog">Internal Bacula Catalog</h3>
<p>Please see the chapter of this manual for more details.</p>
<h3 id="database-table-design">Database Table Design</h3>
<p>All discussions that follow pertain to the MySQL database. The details for the PostgreSQL and SQLite databases are essentially identical except for that all fields in the SQLite database are stored as ASCII text and some of the database creation statements are a bit different. The details of the internal Bacula catalog are not discussed here.</p>
<p>Because the Catalog database may contain very large amounts of data for large sites, we have made a modest attempt to normalize the data tables to reduce redundant information. While reducing the size of the database significantly, it does, unfortunately, add some complications to the structures.</p>
<p>In simple terms, the Catalog database must contain a record of all Jobs run by Bacula, and for each Job, it must maintain a list of all files saved, with their File Attributes (permissions, create date, …), and the location and Media on which the file is stored. This is seemingly a simple task, but it represents a huge amount interlinked data. Note: the list of files and their attributes is not maintained when using the internal Bacula database. The data stored in the File records, which allows the user or administrator to obtain a list of all files backed up during a job, is by far the largest volume of information put into the Catalog database.</p>
<p>Although the Catalog database has been designed to handle backup data for multiple clients, some users may want to maintain multiple databases, one for each machine to be backed up. This reduces the risk of confusion of accidental restoring a file to the wrong machine as well as reducing the amount of data in a single database, thus increasing efficiency and reducing the impact of a lost or damaged database.</p>
<h2 id="sequence-of-creation-of-records-for-a-save-job">Sequence of Creation of Records for a Save Job</h2>
<p>Start with StartDate, ClientName, Filename, Path, Attributes, MediaName, MediaCoordinates. (PartNumber, NumParts). In the steps below, “Create new” means to create a new record whether or not it is unique. “Create unique” means each record in the database should be unique. Thus, one must first search to see if the record exists, and only if not should a new one be created, otherwise the existing RecordId should be used.</p>
<ol style="list-style-type: decimal">
<li><p>Create new Job record with StartDate; save JobId</p></li>
<li><p>Create unique Media record; save MediaId</p></li>
<li><p>Create unique Client record; save ClientId</p></li>
<li><p>Create unique Filename record; save FilenameId</p></li>
<li><p>Create unique Path record; save PathId</p></li>
<li><p>Create unique Attribute record; save AttributeId store ClientId, FilenameId, PathId, and Attributes</p></li>
<li><p>Create new File record store JobId, AttributeId, MediaCoordinates, etc</p></li>
<li><p>Repeat steps 4 through 8 for each file</p></li>
<li><p>Create a JobMedia record; save MediaId</p></li>
<li><p>Update Job record filling in EndDate and other Job statistics</p></li>
</ol>
<h2 id="database-tables">Database Tables</h2>
<p><span>|l|l|l|</span><br /> &amp; &amp;<br /> &amp; <span>integer </span> &amp; <span>Primary Key </span><br /> &amp; <span>Blob </span> &amp; <span>Filename </span><br /> The <span><strong>Filename</strong></span> table shown above contains the name of each file backed up with the path removed. If different directories or machines contain the same filename, only one copy will be saved in this table.</p>
<p><span>|l|l|l|</span><br /> &amp; &amp;<br /> &amp; <span>integer </span> &amp; <span>Primary Key </span><br /> &amp; <span>Blob </span> &amp; <span>Full Path </span><br /> The <span><strong>Path</strong></span> table contains shown above the path or directory names of all directories on the system or systems. The filename and any MSDOS disk name are stripped off. As with the filename, only one copy of each directory name is kept regardless of how many machines or drives have the same directory. These path names should be stored in Unix path name format.</p>
<p>Some simple testing on a Linux file system indicates that separating the filename and the path may be more complication than is warranted by the space savings. For example, this system has a total of 89,097 files, 60,467 of which have unique filenames, and there are 4,374 unique paths.</p>
<p>Finding all those files and doing two stats() per file takes an average wall clock time of 1 min 35 seconds on a 400MHz machine running RedHat 6.1 Linux.</p>
<p>Finding all those files and putting them directly into a MySQL database with the path and filename defined as TEXT, which is variable length up to 65,535 characters takes 19 mins 31 seconds and creates a 27.6 MByte database.</p>
<p>Doing the same thing, but inserting them into Blob fields with the filename indexed on the first 30 characters and the path name indexed on the 255 (max) characters takes 5 mins 18 seconds and creates a 5.24 MB database. Rerunning the job (with the database already created) takes about 2 mins 50 seconds.</p>
<p>Running the same as the last one (Path and Filename Blob), but Filename indexed on the first 30 characters and the Path on the first 50 characters (linear search done there after) takes 5 mins on the average and creates a 3.4 MB database. Rerunning with the data already in the DB takes 3 mins 35 seconds.</p>
<p>Finally, saving only the full path name rather than splitting the path and the file, and indexing it on the first 50 characters takes 6 mins 43 seconds and creates a 7.35 MB database.</p>
<p><span>|l|l|l|</span><br /> &amp; &amp;<br /> &amp; <span>integer </span> &amp; <span>Primary Key </span><br /> &amp; <span>integer </span> &amp; <span>The sequential file number in the Job </span><br /> &amp; <span>integer </span> &amp; <span>Link to Job Record </span><br /> &amp; <span>integer </span> &amp; <span>Link to Path Record </span><br /> &amp; <span>integer </span> &amp; <span>Link to Filename Record </span><br /> &amp; <span>integer </span> &amp; <span>Used to mark files during Verify Jobs </span><br /> &amp; <span>tinyblob </span> &amp; <span>File attributes in base64 encoding </span><br /> &amp; <span>tinyblob </span> &amp; <span>MD5/SHA1 signature in base64 encoding </span><br /> The <span><strong>File</strong></span> table shown above contains one entry for each file backed up by Bacula. Thus a file that is backed up multiple times (as is normal) will have multiple entries in the File table. This will probably be the table with the most number of records. Consequently, it is essential to keep the size of this record to an absolute minimum. At the same time, this table must contain all the information (or pointers to the information) about the file and where it is backed up. Since a file may be backed up many times without having changed, the path and filename are stored in separate tables.</p>
<p>This table contains by far the largest amount of information in the Catalog database, both from the stand point of number of records, and the stand point of total database size. As a consequence, the user must take care to periodically reduce the number of File records using the <span><strong>retention</strong></span> command in the Console program.</p>
<p><span>|l|l|p<span>2.5in</span>|</span><br /> &amp; &amp;<br /> &amp; <span>integer </span> &amp; <span>Primary Key </span><br /> &amp; <span>tinyblob </span> &amp; <span>Unique Job Name </span><br /> &amp; <span>tinyblob </span> &amp; <span>Job Name </span><br /> &amp; <span>tinyint </span> &amp; <span>Used by Bacula for purging/retention periods </span><br /> &amp; <span>binary(1) </span> &amp; <span>Job Type: Backup, Copy, Clone, Archive, Migration </span><br /> &amp; <span>binary(1) </span> &amp; <span>Job Level </span><br /> &amp; <span>integer </span> &amp; <span>Client index </span><br /> &amp; <span>binary(1) </span> &amp; <span>Job Termination Status </span><br /> &amp; <span>datetime </span> &amp; <span>Time/date when Job scheduled </span><br /> &amp; <span>datetime </span> &amp; <span>Time/date when Job started </span><br /> &amp; <span>datetime </span> &amp; <span>Time/date when Job ended </span><br /> &amp; <span>datetime </span> &amp; <span>Time/date when original Job ended </span><br /> &amp; <span>bigint </span> &amp; <span>Start day in Unix format but 64 bits; used for Retention period. </span><br /> &amp; <span>integer </span> &amp; <span>Unique Volume Session ID </span><br /> &amp; <span>integer </span> &amp; <span>Unique Volume Session Time </span><br /> &amp; <span>integer </span> &amp; <span>Number of files saved in Job </span><br /> &amp; <span>bigint </span> &amp; <span>Number of bytes saved in Job </span><br /> &amp; <span>integer </span> &amp; <span>Number of errors during Job </span><br /> &amp; <span>integer </span> &amp; <span>Number of files not saved (not yet used) </span><br /> &amp; <span>integer </span> &amp; <span>Link to Pool Record </span><br /> &amp; <span>integer </span> &amp; <span>Link to FileSet Record </span><br /> &amp; <span>integer </span> &amp; <span>Link to prior Job Record when migrated </span><br /> &amp; <span>tiny integer </span> &amp; <span>Set when all File records purged </span><br /> &amp; <span>tiny integer </span> &amp; <span>Set when Base Job run </span><br /> The <span><strong>Job</strong></span> table contains one record for each Job run by Bacula. Thus normally, there will be one per day per machine added to the database. Note, the JobId is used to index Job records in the database, and it often is shown to the user in the Console program. However, care must be taken with its use as it is not unique from database to database. For example, the user may have a database for Client data saved on machine Rufus and another database for Client data saved on machine Roxie. In this case, the two database will each have JobIds that match those in another database. For a unique reference to a Job, see Job below.</p>
<p>The Name field of the Job record corresponds to the Name resource record given in the Director’s configuration file. Thus it is a generic name, and it will be normal to find many Jobs (or even all Jobs) with the same Name.</p>
<p>The Job field contains a combination of the Name and the schedule time of the Job by the Director. Thus for a given Director, even with multiple Catalog databases, the Job will contain a unique name that represents the Job.</p>
<p>For a given Storage daemon, the VolSessionId and VolSessionTime form a unique identification of the Job. This will be the case even if multiple Directors are using the same Storage daemon.</p>
<p>The Job Type (or simply Type) can have one of the following values:</p>
<p><span>|l|l|</span> &amp;<br /> &amp; <span>Backup Job </span><br /> &amp; <span>Migrated Job </span><br /> &amp; <span>Verify Job </span><br /> &amp; <span>Restore Job </span><br /> &amp; <span>Console program (not in database) </span><br /> &amp; <span>Internal or system Job </span><br /> &amp; <span>Admin Job </span><br /> &amp; <span>Archive Job (not implemented) </span><br /> &amp; <span>Copy Job </span><br /> &amp; <span>Migration Job </span><br /> Note, the Job Type values noted above are not kept in an SQL table.</p>
<p>The JobStatus field specifies how the job terminated, and can be one of the following:</p>
<p><span>|l|l|</span> &amp;<br /> &amp; <span>Created but not yet running </span><br /> &amp; <span>Running </span><br /> &amp; <span>Blocked </span><br /> &amp; <span>Terminated normally </span><br /> &amp; <span>Terminated normally with warnings </span><br /> &amp; <span>Terminated in Error </span><br /> &amp; <span>Non-fatal error </span><br /> &amp; <span>Fatal error </span><br /> &amp; <span>Verify Differences </span><br /> &amp; <span>Canceled by the user </span><br /> &amp; <span>Incomplete Job </span><br /> &amp; <span>Waiting on the File daemon </span><br /> &amp; <span>Waiting on the Storage daemon </span><br /> &amp; <span>Waiting for a new Volume to be mounted </span><br /> &amp; <span>Waiting for a Mount </span><br /> &amp; <span>Waiting for Storage resource </span><br /> &amp; <span>Waiting for Job resource </span><br /> &amp; <span>Waiting for Client resource </span><br /> &amp; <span>Wating for Maximum jobs </span><br /> &amp; <span>Waiting for Start Time </span><br /> &amp; <span>Waiting for higher priority job to finish </span><br /> &amp; <span>Doing batch insert file records </span><br /> &amp; <span>SD despooling attributes </span><br /> &amp; <span>Doing data despooling </span><br /> &amp; <span>Committing data (last despool) </span><br /> <span>|l|l|l|</span><br /> &amp; &amp;<br /> &amp; <span>integer </span> &amp; <span>Primary Key </span><br /> &amp; <span>tinyblob </span> &amp; <span>FileSet name </span><br /> &amp; <span>tinyblob </span> &amp; <span>MD5 checksum of FileSet </span><br /> &amp; <span>datetime </span> &amp; <span>Time and date Fileset created </span><br /> The <span><strong>FileSet</strong></span> table contains one entry for each FileSet that is used. The MD5 signature is kept to ensure that if the user changes anything inside the FileSet, it will be detected and the new FileSet will be used. This is particularly important when doing an incremental update. If the user deletes a file or adds a file, we need to ensure that a Full backup is done prior to the next incremental.</p>
<p><span>|l|l|p<span>2.5in</span>|</span><br /> &amp; &amp;<br /> &amp; <span>integer </span> &amp; <span>Primary Key </span><br /> &amp; <span>integer </span> &amp; <span>Link to Job Record </span><br /> &amp; <span>integer </span> &amp; <span>Link to Media Record </span><br /> &amp; <span>integer </span> &amp; <span>The index (sequence number) of the first file written for this Job to the Media </span><br /> &amp; <span>integer </span> &amp; <span>The index of the last file written for this Job to the Media </span><br /> &amp; <span>integer </span> &amp; <span>The physical media (tape) file number of the first block written for this Job </span><br /> &amp; <span>integer </span> &amp; <span>The physical media (tape) file number of the last block written for this Job </span><br /> &amp; <span>integer </span> &amp; <span>The number of the first block written for this Job </span><br /> &amp; <span>integer </span> &amp; <span>The number of the last block written for this Job </span><br /> &amp; <span>integer </span> &amp; <span>The Volume use sequence number within the Job </span><br /> The <span><strong>JobMedia</strong></span> table contains one entry at the following: start of the job, start of each new tape file, start of each new tape, end of the job. Since by default, a new tape file is written every 2GB, in general, you will have more than 2 JobMedia records per Job. The number can be varied by changing the “Maximum File Size” specified in the Device resource. This record allows Bacula to efficiently position close to (within 2GB) any given file in a backup. For restoring a full Job, these records are not very important, but if you want to retrieve a single file that was written near the end of a 100GB backup, the JobMedia records can speed it up by orders of magnitude by permitting forward spacing files and blocks rather than reading the whole 100GB backup.</p>
<p><span>|l|l|p<span>2.4in</span>|</span><br /> &amp; &amp;<br /> &amp; <span>integer </span> &amp; <span>Primary Key </span><br /> &amp; <span>tinyblob </span> &amp; <span>Volume name </span><br /> &amp; <span>integer </span> &amp; <span>Autochanger Slot number or zero </span><br /> &amp; <span>integer </span> &amp; <span>Link to Pool Record </span><br /> &amp; <span>tinyblob </span> &amp; <span>The MediaType supplied by the user </span><br /> &amp; <span>integer </span> &amp; <span>The MediaTypeId </span><br /> &amp; <span>tinyint </span> &amp; <span>The type of label on the Volume </span><br /> &amp; <span>datetime </span> &amp; <span>Time/date when first written </span><br /> &amp; <span>datetime </span> &amp; <span>Time/date when last written </span><br /> &amp; <span>datetime </span> &amp; <span>Time/date when tape labeled </span><br /> &amp; <span>integer </span> &amp; <span>Number of jobs written to this media </span><br /> &amp; <span>integer </span> &amp; <span>Number of files written to this media </span><br /> &amp; <span>integer </span> &amp; <span>Number of blocks written to this media </span><br /> &amp; <span>integer </span> &amp; <span>Number of time media mounted </span><br /> &amp; <span>bigint </span> &amp; <span>Number of bytes saved in Job </span><br /> &amp; <span>integer </span> &amp; <span>The number of parts for a Volume (DVD) </span><br /> &amp; <span>integer </span> &amp; <span>Number of errors during Job </span><br /> &amp; <span>integer </span> &amp; <span>Number of writes to media </span><br /> &amp; <span>bigint </span> &amp; <span>Maximum bytes to put on this media </span><br /> &amp; <span>bigint </span> &amp; <span>Capacity estimate for this volume </span><br /> &amp; <span>enum </span> &amp; <span>Status of media: Full, Archive, Append, Recycle, Read-Only, Disabled, Error, Busy </span><br /> <span>tinyint </span> &amp; <span>Whether or not Volume can be written </span><br /> &amp; <span>tinyint </span> &amp; <span>Whether or not Bacula can recycle the Volumes: Yes, No </span><br /> &amp; <span>tinyint </span> &amp; <span>What happens to a Volume after purging </span><br /> &amp; <span>bigint </span> &amp; <span>64 bit seconds until expiration </span><br /> &amp; <span>bigint </span> &amp; <span>64 bit seconds volume can be used </span><br /> &amp; <span>integer </span> &amp; <span>maximum jobs to put on Volume </span><br /> &amp; <span>integer </span> &amp; <span>maximume EOF marks to put on Volume </span><br /> &amp; <span>tinyint </span> &amp; <span>Whether or not Volume in autochanger </span><br /> &amp; <span>integer </span> &amp; <span>Storage record ID </span><br /> &amp; <span>integer </span> &amp; <span>Device record ID </span><br /> &amp; <span>integer </span> &amp; <span>Method of addressing media </span><br /> &amp; <span>bigint </span> &amp; <span>Time Reading Volume </span><br /> &amp; <span>bigint </span> &amp; <span>Time Writing Volume </span><br /> &amp; <span>integer </span> &amp; <span>End File number of Volume </span><br /> &amp; <span>integer </span> &amp; <span>End block number of Volume </span><br /> &amp; <span>integer </span> &amp; <span>Location record ID </span><br /> &amp; <span>integer </span> &amp; <span>Number of times recycled </span><br /> &amp; <span>datetime </span> &amp; <span>When Volume first written </span><br /> &amp; <span>integer </span> &amp; <span>Id of Scratch Pool </span><br /> &amp; <span>integer </span> &amp; <span>Pool ID where to recycle Volume </span><br /> &amp; <span>blob </span> &amp; <span>User text field </span><br /> The <span><strong>Volume</strong></span> table (internally referred to as the Media table) contains one entry for each volume, that is each tape, cassette (8mm, DLT, DAT, …), or file on which information is or was backed up. There is one Volume record created for each of the NumVols specified in the Pool resource record.</p>
<p><span>|l|l|p<span>2.4in</span>|</span><br /> &amp; &amp;<br /> &amp; <span>integer </span> &amp; <span>Primary Key </span><br /> &amp; <span>Tinyblob </span> &amp; <span>Pool Name </span><br /> &amp; <span>Integer </span> &amp; <span>Number of Volumes in the Pool </span><br /> &amp; <span>Integer </span> &amp; <span>Maximum Volumes in the Pool </span><br /> &amp; <span>tinyint </span> &amp; <span>Use volume once </span><br /> &amp; <span>tinyint </span> &amp; <span>Set to use catalog </span><br /> &amp; <span>tinyint </span> &amp; <span>Accept any volume from Pool </span><br /> &amp; <span>bigint </span> &amp; <span>64 bit seconds to retain volume </span><br /> &amp; <span>bigint </span> &amp; <span>64 bit seconds volume can be used </span><br /> &amp; <span>integer </span> &amp; <span>max jobs on volume </span><br /> &amp; <span>integer </span> &amp; <span>max EOF marks to put on Volume </span><br /> &amp; <span>bigint </span> &amp; <span>max bytes to write on Volume </span><br /> &amp; <span>tinyint </span> &amp; <span>yes|no for autopruning </span><br /> &amp; <span>tinyint </span> &amp; <span>yes|no for allowing auto recycling of Volume </span><br /> &amp; <span>tinyint </span> &amp; <span>Default Volume ActionOnPurge </span><br /> &amp; <span>enum </span> &amp; <span>Backup, Copy, Cloned, Archive, Migration </span><br /> &amp; <span>tinyint </span> &amp; <span>Type of label ANSI/Bacula </span><br /> &amp; <span>Tinyblob </span> &amp; <span>Label format </span><br /> <span>tinyint </span> &amp; <span>Whether or not Volume can be written </span><br /> &amp; <span>integer </span> &amp; <span>Id of Scratch Pool </span><br /> &amp; <span>integer </span> &amp; <span>Pool ID where to recycle Volume </span><br /> &amp; <span>integer </span> &amp; <span>Pool ID of next Pool </span><br /> &amp; <span>bigint </span> &amp; <span>High water mark for migration </span><br /> &amp; <span>bigint </span> &amp; <span>Low water mark for migration </span><br /> &amp; <span>bigint </span> &amp; <span>Time before migration </span><br /> The <span><strong>Pool</strong></span> table contains one entry for each media pool controlled by Bacula in this database. One media record exists for each of the NumVols contained in the Pool. The PoolType is a Bacula defined keyword. The MediaType is defined by the administrator, and corresponds to the MediaType specified in the Director’s Storage definition record. The CurrentVol is the sequence number of the Media record for the current volume.</p>
<p><span>|l|l|l|</span><br /> &amp; &amp;<br /> &amp; <span>integer </span> &amp; <span>Primary Key </span><br /> &amp; <span>TinyBlob </span> &amp; <span>File Services Name </span><br /> &amp; <span>TinyBlob </span> &amp; <span>uname -a from Client (not yet used) </span><br /> &amp; <span>tinyint </span> &amp; <span>yes|no for autopruning </span><br /> &amp; <span>bigint </span> &amp; <span>64 bit seconds to retain Files </span><br /> &amp; <span>bigint </span> &amp; <span>64 bit seconds to retain Job </span><br /> The <span><strong>Client</strong></span> table contains one entry for each machine backed up by Bacula in this database. Normally the Name is a fully qualified domain name.</p>
<p><span>|l|l|l|</span><br /> &amp; &amp;<br /> &amp; <span>integer </span> &amp; <span>Unique Id </span><br /> &amp; <span>tinyblob </span> &amp; <span>Resource name of Storage device </span><br /> &amp; <span>tinyint </span> &amp; <span>Set if it is an autochanger </span><br /> The <span><strong>Storage</strong></span> table contains one entry for each Storage used.</p>
<p><span>|l|l|l|</span><br /> &amp; &amp;<br /> &amp; <span>tinyblob </span> &amp; <span>Counter name </span><br /> &amp; <span>integer </span> &amp; <span>Start/Min value for counter </span><br /> &amp; <span>integer </span> &amp; <span>Max value for counter </span><br /> &amp; <span>integer </span> &amp; <span>Current counter value </span><br /> &amp; <span>tinyblob </span> &amp; <span>Name of another counter </span><br /> The <span><strong>Counter</strong></span> table contains one entry for each permanent counter defined by the user.</p>
<p><span>|l|l|p<span>2.5in</span>|</span><br /> &amp; &amp;<br /> &amp; <span>integer </span> &amp; <span>Primary Key </span><br /> &amp; <span>tinyblob </span> &amp; <span>Unique Job Name </span><br /> &amp; <span>tinyblob </span> &amp; <span>Job Name </span><br /> &amp; <span>binary(1) </span> &amp; <span>Job Type: Backup, Copy, Clone, Archive, Migration </span><br /> &amp; <span>binary(1) </span> &amp; <span>Job Level </span><br /> &amp; <span>integer </span> &amp; <span>Client index </span><br /> &amp; <span>binary(1) </span> &amp; <span>Job Termination Status </span><br /> &amp; <span>datetime </span> &amp; <span>Time/date when Job scheduled </span><br /> &amp; <span>datetime </span> &amp; <span>Time/date when Job started </span><br /> &amp; <span>datetime </span> &amp; <span>Time/date when Job ended </span><br /> &amp; <span>datetime </span> &amp; <span>Time/date when original Job ended </span><br /> &amp; <span>bigint </span> &amp; <span>Start day in Unix format but 64 bits; used for Retention period. </span><br /> &amp; <span>integer </span> &amp; <span>Unique Volume Session ID </span><br /> &amp; <span>integer </span> &amp; <span>Unique Volume Session Time </span><br /> &amp; <span>integer </span> &amp; <span>Number of files saved in Job </span><br /> &amp; <span>bigint </span> &amp; <span>Number of bytes saved in Job </span><br /> &amp; <span>integer </span> &amp; <span>Number of errors during Job </span><br /> &amp; <span>integer </span> &amp; <span>Number of files not saved (not yet used) </span><br /> &amp; <span>integer </span> &amp; <span>Link to Pool Record </span><br /> &amp; <span>integer </span> &amp; <span>Link to FileSet Record </span><br /> &amp; <span>integer </span> &amp; <span>Link to prior Job Record when migrated </span><br /> &amp; <span>tiny integer </span> &amp; <span>Set when all File records purged </span><br /> &amp; <span>tiny integer </span> &amp; <span>Set when Base Job run </span><br /> The <span>bf JobHisto</span> table is the same as the Job table, but it keeps long term statistics (i.e. it is not pruned with the Job).</p>
<p><span>|l|l|l|</span><br /> &amp; &amp;<br /> &amp; <span>integer </span> &amp; <span>Primary Key </span><br /> &amp; <span>integer </span> &amp; <span>Points to Job record </span><br /> &amp; <span>datetime </span> &amp; <span>Time/date log record created </span><br /> &amp; <span>blob </span> &amp; <span>Log text </span><br /> The <span><strong>Log</strong></span> table contains a log of all Job output.</p>
<p><span>|l|l|l|</span><br /> &amp; &amp;<br /> &amp; <span>integer </span> &amp; <span>Primary Key </span><br /> &amp; <span>tinyblob </span> &amp; <span>Text defining location </span><br /> &amp; <span>integer </span> &amp; <span>Relative cost of obtaining Volume </span><br /> &amp; <span>tinyint </span> &amp; <span>Whether or not Volume is enabled </span><br /> The <span><strong>Location</strong></span> table defines where a Volume is physically.</p>
<p><span>|l|l|l|</span><br /> &amp; &amp;<br /> &amp; <span>integer </span> &amp; <span>Primary Key </span><br /> &amp; <span>datetime </span> &amp; <span>Time/date log record created </span><br /> &amp; <span>integer </span> &amp; <span>Points to Media record </span><br /> &amp; <span>integer </span> &amp; <span>Points to Location record </span><br /> &amp; <span>integer </span> &amp; <span>enum: Full, Archive, Append, Recycle, Purged Read-only, Disabled, Error, Busy, Used, Cleaning </span><br /> &amp; <span>tinyint </span> &amp; <span>Whether or not Volume is enabled </span><br /> The <span><strong>Log</strong></span> table contains a log of all Job output.</p>
<p><span>|l|l|l|</span><br /> &amp; &amp;<br /> &amp; <span>integer </span> &amp; <span>Primary Key </span><br /> The <span><strong>Version</strong></span> table defines the Bacula database version number. Bacula checks this number before reading the database to ensure that it is compatible with the Bacula binary file.</p>
<p><span>|l|l|l|</span><br /> &amp; &amp;<br /> &amp; <span>integer </span> &amp; <span>Primary Key </span><br /> &amp; <span>integer </span> &amp; <span>JobId of Base Job </span><br /> &amp; <span>integer </span> &amp; <span>Reference to Job </span><br /> &amp; <span>integer </span> &amp; <span>Reference to File </span><br /> &amp; <span>integer </span> &amp; <span>File Index number </span><br /> The <span><strong>BaseFiles</strong></span> table contains all the File references for a particular JobId that point to a Base file – i.e. they were previously saved and hence were not saved in the current JobId but in BaseJobId under FileId. FileIndex is the index of the file, and is used for optimization of Restore jobs to prevent the need to read the FileId record when creating the in memory tree. This record is not yet implemented.</p>
<h3 id="mysql-table-definition">MySQL Table Definition</h3>
<p>The commands used to create the MySQL tables are as follows:</p>
<pre><code>USE bacula;
CREATE TABLE Filename (
  FilenameId INTEGER UNSIGNED NOT NULL AUTO_INCREMENT,
  Name BLOB NOT NULL,
  PRIMARY KEY(FilenameId),
  INDEX (Name(30))
  );
CREATE TABLE Path (
   PathId INTEGER UNSIGNED NOT NULL AUTO_INCREMENT,
   Path BLOB NOT NULL,
   PRIMARY KEY(PathId),
   INDEX (Path(50))
   );
CREATE TABLE File (
   FileId INTEGER UNSIGNED NOT NULL AUTO_INCREMENT,
   FileIndex INTEGER UNSIGNED NOT NULL DEFAULT 0,
   JobId INTEGER UNSIGNED NOT NULL REFERENCES Job,
   PathId INTEGER UNSIGNED NOT NULL REFERENCES Path,
   FilenameId INTEGER UNSIGNED NOT NULL REFERENCES Filename,
   MarkId INTEGER UNSIGNED NOT NULL DEFAULT 0,
   LStat TINYBLOB NOT NULL,
   MD5 TINYBLOB NOT NULL,
   PRIMARY KEY(FileId),
   INDEX (JobId),
   INDEX (PathId),
   INDEX (FilenameId)
   );
CREATE TABLE Job (
   JobId INTEGER UNSIGNED NOT NULL AUTO_INCREMENT,
   Job TINYBLOB NOT NULL,
   Name TINYBLOB NOT NULL,
   Type BINARY(1) NOT NULL,
   Level BINARY(1) NOT NULL,
   ClientId INTEGER NOT NULL REFERENCES Client,
   JobStatus BINARY(1) NOT NULL,
   SchedTime DATETIME NOT NULL,
   StartTime DATETIME NOT NULL,
   EndTime DATETIME NOT NULL,
   JobTDate BIGINT UNSIGNED NOT NULL,
   VolSessionId INTEGER UNSIGNED NOT NULL DEFAULT 0,
   VolSessionTime INTEGER UNSIGNED NOT NULL DEFAULT 0,
   JobFiles INTEGER UNSIGNED NOT NULL DEFAULT 0,
   JobBytes BIGINT UNSIGNED NOT NULL,
   JobErrors INTEGER UNSIGNED NOT NULL DEFAULT 0,
   JobMissingFiles INTEGER UNSIGNED NOT NULL DEFAULT 0,
   PoolId INTEGER UNSIGNED NOT NULL REFERENCES Pool,
   FileSetId INTEGER UNSIGNED NOT NULL REFERENCES FileSet,
   PurgedFiles TINYINT NOT NULL DEFAULT 0,
   HasBase TINYINT NOT NULL DEFAULT 0,
   PRIMARY KEY(JobId),
   INDEX (Name(128))
   );
CREATE TABLE FileSet (
   FileSetId INTEGER UNSIGNED NOT NULL AUTO_INCREMENT,
   FileSet TINYBLOB NOT NULL,
   MD5 TINYBLOB NOT NULL,
   CreateTime DATETIME NOT NULL,
   PRIMARY KEY(FileSetId)
   );
CREATE TABLE JobMedia (
   JobMediaId INTEGER UNSIGNED NOT NULL AUTO_INCREMENT,
   JobId INTEGER UNSIGNED NOT NULL REFERENCES Job,
   MediaId INTEGER UNSIGNED NOT NULL REFERENCES Media,
   FirstIndex INTEGER UNSIGNED NOT NULL DEFAULT 0,
   LastIndex INTEGER UNSIGNED NOT NULL DEFAULT 0,
   StartFile INTEGER UNSIGNED NOT NULL DEFAULT 0,
   EndFile INTEGER UNSIGNED NOT NULL DEFAULT 0,
   StartBlock INTEGER UNSIGNED NOT NULL DEFAULT 0,
   EndBlock INTEGER UNSIGNED NOT NULL DEFAULT 0,
   VolIndex INTEGER UNSIGNED NOT NULL DEFAULT 0,
   PRIMARY KEY(JobMediaId),
   INDEX (JobId, MediaId)
   );
CREATE TABLE Media (
   MediaId INTEGER UNSIGNED NOT NULL AUTO_INCREMENT,
   VolumeName TINYBLOB NOT NULL,
   Slot INTEGER NOT NULL DEFAULT 0,
   PoolId INTEGER UNSIGNED NOT NULL REFERENCES Pool,
   MediaType TINYBLOB NOT NULL,
   FirstWritten DATETIME NOT NULL,
   LastWritten DATETIME NOT NULL,
   LabelDate DATETIME NOT NULL,
   VolJobs INTEGER UNSIGNED NOT NULL DEFAULT 0,
   VolFiles INTEGER UNSIGNED NOT NULL DEFAULT 0,
   VolBlocks INTEGER UNSIGNED NOT NULL DEFAULT 0,
   VolMounts INTEGER UNSIGNED NOT NULL DEFAULT 0,
   VolBytes BIGINT UNSIGNED NOT NULL DEFAULT 0,
   VolErrors INTEGER UNSIGNED NOT NULL DEFAULT 0,
   VolWrites INTEGER UNSIGNED NOT NULL DEFAULT 0,
   VolCapacityBytes BIGINT UNSIGNED NOT NULL,
   VolStatus ENUM(&#39;Full&#39;, &#39;Archive&#39;, &#39;Append&#39;, &#39;Recycle&#39;, &#39;Purged&#39;,
    &#39;Read-Only&#39;, &#39;Disabled&#39;, &#39;Error&#39;, &#39;Busy&#39;, &#39;Used&#39;, &#39;Cleaning&#39;) NOT NULL,
   Recycle TINYINT NOT NULL DEFAULT 0,
   VolRetention BIGINT UNSIGNED NOT NULL DEFAULT 0,
   VolUseDuration BIGINT UNSIGNED NOT NULL DEFAULT 0,
   MaxVolJobs INTEGER UNSIGNED NOT NULL DEFAULT 0,
   MaxVolFiles INTEGER UNSIGNED NOT NULL DEFAULT 0,
   MaxVolBytes BIGINT UNSIGNED NOT NULL DEFAULT 0,
   InChanger TINYINT NOT NULL DEFAULT 0,
   MediaAddressing TINYINT NOT NULL DEFAULT 0,
   VolReadTime BIGINT UNSIGNED NOT NULL DEFAULT 0,
   VolWriteTime BIGINT UNSIGNED NOT NULL DEFAULT 0,
   PRIMARY KEY(MediaId),
   INDEX (PoolId)
   );
CREATE TABLE Pool (
   PoolId INTEGER UNSIGNED NOT NULL AUTO_INCREMENT,
   Name TINYBLOB NOT NULL,
   NumVols INTEGER UNSIGNED NOT NULL DEFAULT 0,
   MaxVols INTEGER UNSIGNED NOT NULL DEFAULT 0,
   UseOnce TINYINT NOT NULL,
   UseCatalog TINYINT NOT NULL,
   AcceptAnyVolume TINYINT DEFAULT 0,
   VolRetention BIGINT UNSIGNED NOT NULL,
   VolUseDuration BIGINT UNSIGNED NOT NULL,
   MaxVolJobs INTEGER UNSIGNED NOT NULL DEFAULT 0,
   MaxVolFiles INTEGER UNSIGNED NOT NULL DEFAULT 0,
   MaxVolBytes BIGINT UNSIGNED NOT NULL,
   AutoPrune TINYINT DEFAULT 0,
   Recycle TINYINT DEFAULT 0,
   PoolType ENUM(&#39;Backup&#39;, &#39;Copy&#39;, &#39;Cloned&#39;, &#39;Archive&#39;, &#39;Migration&#39;, &#39;Scratch&#39;) NOT NULL,
   LabelFormat TINYBLOB,
   Enabled TINYINT DEFAULT 1,
   ScratchPoolId INTEGER UNSIGNED DEFAULT 0 REFERENCES Pool,
   RecyclePoolId INTEGER UNSIGNED DEFAULT 0 REFERENCES Pool,
   UNIQUE (Name(128)),
   PRIMARY KEY (PoolId)
   );
CREATE TABLE Client (
   ClientId INTEGER UNSIGNED NOT NULL AUTO_INCREMENT,
   Name TINYBLOB NOT NULL,
   Uname TINYBLOB NOT NULL,       /* full uname -a of client */
   AutoPrune TINYINT DEFAULT 0,
   FileRetention BIGINT UNSIGNED NOT NULL,
   JobRetention  BIGINT UNSIGNED NOT NULL,
   UNIQUE (Name(128)),
   PRIMARY KEY(ClientId)
   );
CREATE TABLE BaseFiles (
   BaseId INTEGER UNSIGNED AUTO_INCREMENT,
   BaseJobId INTEGER UNSIGNED NOT NULL REFERENCES Job,
   JobId INTEGER UNSIGNED NOT NULL REFERENCES Job,
   FileId INTEGER UNSIGNED NOT NULL REFERENCES File,
   FileIndex INTEGER UNSIGNED,
   PRIMARY KEY(BaseId)
   );
CREATE TABLE UnsavedFiles (
   UnsavedId INTEGER UNSIGNED AUTO_INCREMENT,
   JobId INTEGER UNSIGNED NOT NULL REFERENCES Job,
   PathId INTEGER UNSIGNED NOT NULL REFERENCES Path,
   FilenameId INTEGER UNSIGNED NOT NULL REFERENCES Filename,
   PRIMARY KEY (UnsavedId)
   );
CREATE TABLE Version (
   VersionId INTEGER UNSIGNED NOT NULL
   );
-- Initialize Version
INSERT INTO Version (VersionId) VALUES (7);
CREATE TABLE Counters (
   Counter TINYBLOB NOT NULL,
   MinValue INTEGER,
   MaxValue INTEGER,
   CurrentValue INTEGER,
   WrapCounter TINYBLOB NOT NULL,
   PRIMARY KEY (Counter(128))
   );</code></pre>
<p>Storage Media Output Format {#_ChapterStart9} ===========================</p>
<h2 id="general-3">General</h2>
<p>This document describes the media format written by the Storage daemon. The Storage daemon reads and writes in units of blocks. Blocks contain records. Each block has a block header followed by records, and each record has a record header followed by record data.</p>
<p>This chapter is intended to be a technical discussion of the Media Format and as such is not targeted at end users but rather at developers and system administrators that want or need to know more of the working details of <span><strong>Bacula</strong></span>.</p>
<h2 id="definitions">Definitions</h2>
<dl>
<dt>Block</dt>
<dd><p>A block represents the primitive unit of information that the Storage daemon reads and writes to a physical device. Normally, for a tape device, it will be the same as a tape block. The Storage daemon always reads and writes blocks. A block consists of block header information followed by records. Clients of the Storage daemon (the File daemon) normally never see blocks. However, some of the Storage tools (bls, bscan, bextract, …) may be use block header information. In older Bacula tape versions, a block could contain records (see record definition below) from multiple jobs. However, all blocks currently written by Bacula are block level BB02, and a given block contains records for only a single job. Different jobs simply have their own private blocks that are intermingled with the other blocks from other jobs on the Volume (previously the records were intermingled within the blocks). Having only records from a single job in any give block permitted moving the VolumeSessionId and VolumeSessionTime (see below) from each record heading to the Block header. This has two advantages: 1. a block can be quickly rejected based on the contents of the header without reading all the records. 2. because there is on the average more than one record per block, less data is written to the Volume for each job.</p>
</dd>
<dt>Record</dt>
<dd><p>A record consists of a Record Header, which is managed by the Storage daemon and Record Data, which is the data received from the Client. A record is the primitive unit of information sent to and from the Storage daemon by the Client (File daemon) programs. The details are described below.</p>
</dd>
<dt>JobId</dt>
<dd><p>A number assigned by the Director daemon for a particular job. This number will be unique for that particular Director (Catalog). The daemons use this number to keep track of individual jobs. Within the Storage daemon, the JobId may not be unique if several Directors are accessing the Storage daemon simultaneously.</p>
</dd>
<dt>Session</dt>
<dd><p>A Session is a concept used in the Storage daemon corresponds one to one to a Job with the exception that each session is uniquely identified within the Storage daemon by a unique SessionId/SessionTime pair (see below).</p>
</dd>
<dt>VolSessionId</dt>
<dd><p>A unique number assigned by the Storage daemon to a particular session (Job) it is having with a File daemon. This number by itself is not unique to the given Volume, but with the VolSessionTime, it is unique.</p>
</dd>
<dt>VolSessionTime</dt>
<dd><p>A unique number assigned by the Storage daemon to a particular Storage daemon execution. It is actually the Unix time_t value of when the Storage daemon began execution cast to a 32 bit unsigned integer. The combination of the <span><strong>VolSessionId</strong></span> and the <span><strong>VolSessionTime</strong></span> for a given Storage daemon is guaranteed to be unique for each Job (or session).</p>
</dd>
<dt>FileIndex</dt>
<dd><p>A sequential number beginning at one assigned by the File daemon to the files within a job that are sent to the Storage daemon for backup. The Storage daemon ensures that this number is greater than zero and sequential. Note, the Storage daemon uses negative FileIndexes to flag Session Start and End Labels as well as End of Volume Labels. Thus, the combination of VolSessionId, VolSessionTime, and FileIndex uniquely identifies the records for a single file written to a Volume.</p>
</dd>
<dt>Stream</dt>
<dd><p>While writing the information for any particular file to the Volume, there can be any number of distinct pieces of information about that file, e.g. the attributes, the file data, … The Stream indicates what piece of data it is, and it is an arbitrary number assigned by the File daemon to the parts (Unix attributes, Win32 attributes, data, compressed data, …) of a file that are sent to the Storage daemon. The Storage daemon has no knowledge of the details of a Stream; it simply represents a numbered stream of bytes. The data for a given stream may be passed to the Storage daemon in single record, or in multiple records.</p>
</dd>
<dt>Block Header</dt>
<dd><p>A block header consists of a block identification (“BB02”), a block length in bytes (typically 64,512) a checksum, and sequential block number. Each block starts with a Block Header and is followed by Records. Current block headers also contain the VolSessionId and VolSessionTime for the records written to that block.</p>
</dd>
<dt>Record Header</dt>
<dd><p>A record header contains the Volume Session Id, the Volume Session Time, the FileIndex, the Stream, and the size of the data record which follows. The Record Header is always immediately followed by a Data Record if the size given in the Header is greater than zero. Note, for Block headers of level BB02 (version 1.27 and later), the Record header as written to tape does not contain the Volume Session Id and the Volume Session Time as these two fields are stored in the BB02 Block header. The in-memory record header does have those fields for convenience.</p>
</dd>
<dt>Data Record</dt>
<dd><p>A data record consists of a binary stream of bytes and is always preceded by a Record Header. The details of the meaning of the binary stream of bytes are unknown to the Storage daemon, but the Client programs (File daemon) defines and thus knows the details of each record type.</p>
</dd>
<dt>Volume Label</dt>
<dd><p>A label placed by the Storage daemon at the beginning of each storage volume. It contains general information about the volume. It is written in Record format. The Storage daemon manages Volume Labels, and if the client wants, he may also read them.</p>
</dd>
<dt>Begin Session Label</dt>
<dd><p>The Begin Session Label is a special record placed by the Storage daemon on the storage medium as the first record of an append session job with a File daemon. This record is useful for finding the beginning of a particular session (Job), since no records with the same VolSessionId and VolSessionTime will precede this record. This record is not normally visible outside of the Storage daemon. The Begin Session Label is similar to the Volume Label except that it contains additional information pertaining to the Session.</p>
</dd>
<dt>End Session Label</dt>
<dd><p>The End Session Label is a special record placed by the Storage daemon on the storage medium as the last record of an append session job with a File daemon. The End Session Record is distinguished by a FileIndex with a value of minus two (-2). This record is useful for detecting the end of a particular session since no records with the same VolSessionId and VolSessionTime will follow this record. This record is not normally visible outside of the Storage daemon. The End Session Label is similar to the Volume Label except that it contains additional information pertaining to the Session.</p>
</dd>
</dl>
<h2 id="storage-daemon-file-output-format">Storage Daemon File Output Format</h2>
<p>The file storage and tape storage formats are identical except that tape records are by default blocked into blocks of 64,512 bytes, except for the last block, which is the actual number of bytes written rounded up to a multiple of 1024 whereas the last record of file storage is not rounded up. The default block size of 64,512 bytes may be overridden by the user (some older tape drives only support block sizes of 32K). Each Session written to tape is terminated with an End of File mark (this will be removed later). Sessions written to file are simply appended to the end of the file.</p>
<h2 id="overall-format">Overall Format</h2>
<p>A Bacula output file consists of Blocks of data. Each block contains a block header followed by records. Each record consists of a record header followed by the record data. The first record on a tape will always be the Volume Label Record.</p>
<p>No Record Header will be split across Bacula blocks. However, Record Data may be split across any number of Bacula blocks. Obviously this will not be the case for the Volume Label which will always be smaller than the Bacula Block size.</p>
<p>To simplify reading tapes, the Start of Session (SOS) and End of Session (EOS) records are never split across blocks. If this is about to happen, Bacula will write a short block before writing the session record (actually, the SOS record should always be the first record in a block, excepting perhaps the Volume label).</p>
<p>Due to hardware limitations, the last block written to the tape may not be fully written. If your drive permits backspace record, Bacula will backup over the last record written on the tape, re-read it and verify that it was correctly written.</p>
<p>When a new tape is mounted Bacula will write the full contents of the partially written block to the new tape ensuring that there is no loss of data. When reading a tape, Bacula will discard any block that is not totally written, thus ensuring that there is no duplication of data. In addition, since Bacula blocks are sequentially numbered within a Job, it is easy to ensure that no block is missing or duplicated.</p>
<h2 id="serialization">Serialization</h2>
<p>All Block Headers, Record Headers, and Label Records are written using Bacula’s serialization routines. These routines guarantee that the data is written to the output volume in a machine independent format.</p>
<h2 id="block-header">Block Header</h2>
<p>The format of the Block Header (version 1.27 and later) is:</p>
<pre><code>   uint32_t CheckSum;                /* Block check sum */
   uint32_t BlockSize;               /* Block byte size including the header */
   uint32_t BlockNumber;             /* Block number */
   char ID[4] = &quot;BB02&quot;;              /* Identification and block level */
   uint32_t VolSessionId;            /* Session Id for Job */
   uint32_t VolSessionTime;          /* Session Time for Job */</code></pre>
<p>The Block header is a fixed length and fixed format and is followed by Record Headers and Record Data. The CheckSum field is a 32 bit checksum of the block data and the block header but not including the CheckSum field. The Block Header is always immediately followed by a Record Header. If the tape is damaged, a Bacula utility will be able to recover as much information as possible from the tape by recovering blocks which are valid. The Block header is written using the Bacula serialization routines and thus is guaranteed to be in machine independent format. See below for version 2 of the block header.</p>
<h2 id="record-header">Record Header</h2>
<p>Each binary data record is preceded by a Record Header. The Record Header is fixed length and fixed format, whereas the binary data record is of variable length. The Record Header is written using the Bacula serialization routines and thus is guaranteed to be in machine independent format.</p>
<p>The format of the Record Header (version 1.27 or later) is:</p>
<pre><code>  int32_t FileIndex;   /* File index supplied by File daemon */
  int32_t Stream;      /* Stream number supplied by File daemon */
  uint32_t DataSize;   /* size of following data record in bytes */</code></pre>
<p>This record is followed by the binary Stream data of DataSize bytes, followed by another Record Header record and the binary stream data. For the definitive definition of this record, see record.h in the src/stored directory.</p>
<p>Additional notes on the above:</p>
<dl>
<dt>The <span><strong>VolSessionId</strong></span></dt>
<dd><p>is a unique sequential number that is assigned by the Storage Daemon to a particular Job. This number is sequential since the start of execution of the daemon.</p>
</dd>
<dt>The <span><strong>VolSessionTime</strong></span></dt>
<dd><p>is the time/date that the current execution of the Storage Daemon started. It assures that the combination of VolSessionId and VolSessionTime is unique for every jobs written to the tape, even if there was a machine crash between two writes.</p>
</dd>
<dt>The <span><strong>FileIndex</strong></span></dt>
<dd><p>is a sequential file number within a job. The Storage daemon requires this index to be greater than zero and sequential. Note, however, that the File daemon may send multiple Streams for the same FileIndex. In addition, the Storage daemon uses negative FileIndices to hold the Begin Session Label, the End Session Label, and the End of Volume Label.</p>
</dd>
<dt>The <span><strong>Stream</strong></span></dt>
<dd><p>is defined by the File daemon and is used to identify separate parts of the data saved for each file (Unix attributes, Win32 attributes, file data, compressed file data, sparse file data, …). The Storage Daemon has no idea of what a Stream is or what it contains except that the Stream is required to be a positive integer. Negative Stream numbers are used internally by the Storage daemon to indicate that the record is a continuation of the previous record (the previous record would not entirely fit in the block).</p>
<p>For Start Session and End Session Labels (where the FileIndex is negative), the Storage daemon uses the Stream field to contain the JobId. The current stream definitions are:</p>
<pre><code>#define STREAM_UNIX_ATTRIBUTES    1    /* Generic Unix attributes */
#define STREAM_FILE_DATA          2    /* Standard uncompressed data */
#define STREAM_MD5_SIGNATURE      3    /* MD5 signature for the file */
#define STREAM_GZIP_DATA          4    /* GZip compressed file data */
/* Extended Unix attributes with Win32 Extended data.  Deprecated. */
#define STREAM_UNIX_ATTRIBUTES_EX 5    /* Extended Unix attr for Win32 EX */
#define STREAM_SPARSE_DATA        6    /* Sparse data stream */
#define STREAM_SPARSE_GZIP_DATA   7
#define STREAM_PROGRAM_NAMES      8    /* program names for program data */
#define STREAM_PROGRAM_DATA       9    /* Data needing program */
#define STREAM_SHA1_SIGNATURE    10    /* SHA1 signature for the file */
#define STREAM_WIN32_DATA        11    /* Win32 BackupRead data */
#define STREAM_WIN32_GZIP_DATA   12    /* Gzipped Win32 BackupRead data */
#define STREAM_MACOS_FORK_DATA   13    /* Mac resource fork */
#define STREAM_HFSPLUS_ATTRIBUTES 14   /* Mac OS extra attributes */
#define STREAM_UNIX_ATTRIBUTES_ACCESS_ACL 15 /* Standard ACL attributes on UNIX */
#define STREAM_UNIX_ATTRIBUTES_DEFAULT_ACL 16 /* Default ACL attributes on UNIX */</code></pre>
</dd>
<dt>The <span><strong>DataSize</strong></span></dt>
<dd><p>is the size in bytes of the binary data record that follows the Session Record header. The Storage Daemon has no idea of the actual contents of the binary data record. For standard Unix files, the data record typically contains the file attributes or the file data. For a sparse file the first 64 bits of the file data contains the storage address for the data block.</p>
</dd>
</dl>
<p>The Record Header is never split across two blocks. If there is not enough room in a block for the full Record Header, the block is padded to the end with zeros and the Record Header begins in the next block. The data record, on the other hand, may be split across multiple blocks and even multiple physical volumes. When a data record is split, the second (and possibly subsequent) piece of the data is preceded by a new Record Header. Thus each piece of data is always immediately preceded by a Record Header. When reading a record, if Bacula finds only part of the data in the first record, it will automatically read the next record and concatenate the data record to form a full data record.</p>
<h2 id="version-bb02-block-header">Version BB02 Block Header</h2>
<p>Each session or Job has its own private block. As a consequence, the SessionId and SessionTime are written once in each Block Header and not in the Record Header. So, the second and current version of the Block Header BB02 is:</p>
<pre><code>   uint32_t CheckSum;        /* Block check sum */
   uint32_t BlockSize;       /* Block byte size including the header */
   uint32_t BlockNumber;     /* Block number */
   char ID[4] = &quot;BB02&quot;;      /* Identification and block level */
   uint32_t VolSessionId;    /* Applies to all records  */
   uint32_t VolSessionTime;  /*   contained in this block */</code></pre>
<p>As with the previous version, the BB02 Block header is a fixed length and fixed format and is followed by Record Headers and Record Data. The CheckSum field is a 32 bit CRC checksum of the block data and the block header but not including the CheckSum field. The Block Header is always immediately followed by a Record Header. If the tape is damaged, a Bacula utility will be able to recover as much information as possible from the tape by recovering blocks which are valid. The Block header is written using the Bacula serialization routines and thus is guaranteed to be in machine independent format.</p>
<h2 id="version-2-record-header">Version 2 Record Header</h2>
<p>Version 2 Record Header is written to the medium when using Version BB02 Block Headers. The memory representation of the record is identical to the old BB01 Record Header, but on the storage medium, the first two fields, namely VolSessionId and VolSessionTime are not written. The Block Header is filled with these values when the First user record is written (i.e. non label record) so that when the block is written, it will have the current and unique VolSessionId and VolSessionTime. On reading each record from the Block, the VolSessionId and VolSessionTime is filled in the Record Header from the Block Header.</p>
<h2 id="volume-label-format">Volume Label Format</h2>
<p>Tape volume labels are created by the Storage daemon in response to a <span><strong>label</strong></span> command given to the Console program, or alternatively by the <span><strong>btape</strong></span> program. created. Each volume is labeled with the following information using the Bacula serialization routines, which guarantee machine byte order independence.</p>
<p>For Bacula versions 1.27 and later, the Volume Label Format is:</p>
<pre><code>  char Id[32];              /* Bacula 1.0 Immortal\n */
  uint32_t VerNum;          /* Label version number */
  /* VerNum 11 and greater Bacula 1.27 and later */
  btime_t   label_btime;    /* Time/date tape labeled */
  btime_t   write_btime;    /* Time/date tape first written */
  /* The following are 0 in VerNum 11 and greater */
  float64_t write_date;     /* Date this label written */
  float64_t write_time;     /* Time this label written */
  char VolName[128];        /* Volume name */
  char PrevVolName[128];    /* Previous Volume Name */
  char PoolName[128];       /* Pool name */
  char PoolType[128];       /* Pool type */
  char MediaType[128];      /* Type of this media */
  char HostName[128];       /* Host name of writing computer */
  char LabelProg[32];       /* Label program name */
  char ProgVersion[32];     /* Program version */
  char ProgDate[32];        /* Program build date/time */</code></pre>
<p>Note, the LabelType (Volume Label, Volume PreLabel, Session Start Label, …) is stored in the record FileIndex field of the Record Header and does not appear in the data part of the record.</p>
<h2 id="session-label">Session Label</h2>
<p>The Session Label is written at the beginning and end of each session as well as the last record on the physical medium. It has the following binary format:</p>
<pre><code>  char Id[32];              /* Bacula Immortal ... */
  uint32_t VerNum;          /* Label version number */
  uint32_t JobId;           /* Job id */
  uint32_t VolumeIndex;     /* sequence no of vol */
  /* Prior to VerNum 11 */
  float64_t write_date;     /* Date this label written */
  /* VerNum 11 and greater */
  btime_t   write_btime;    /* time/date record written */
  /* The following is zero VerNum 11 and greater */
  float64_t write_time;    /* Time this label written */
  char PoolName[128];        /* Pool name */
  char PoolType[128];        /* Pool type */
  char JobName[128];         /* base Job name */
  char ClientName[128];
  /* Added in VerNum 10 */
  char Job[128];             /* Unique Job name */
  char FileSetName[128];     /* FileSet name */
  uint32_t JobType;
  uint32_t JobLevel;</code></pre>
<p>In addition, the EOS label contains:</p>
<pre><code>  /* The remainder are part of EOS label only */
  uint32_t JobFiles;
  uint64_t JobBytes;
  uint32_t start_block;
  uint32_t end_block;
  uint32_t start_file;
  uint32_t end_file;
  uint32_t JobErrors;</code></pre>
<p>In addition, for VerNum greater than 10, the EOS label contains (in addition to the above):</p>
<pre><code>  uint32_t JobStatus          /* Job termination code */</code></pre>
<p>: Note, the LabelType (Volume Label, Volume PreLabel, Session Start Label, …) is stored in the record FileIndex field and does not appear in the data part of the record. Also, the Stream field of the Record Header contains the JobId. This permits quick filtering without actually reading all the session data in many cases.</p>
<h2 id="overall-storage-format">Overall Storage Format</h2>
<pre><code>               Current Bacula Tape Format
                     6 June 2001
           Version BB02 added 28 September 2002
           Version BB01 is the old deprecated format.
   A Bacula tape is composed of tape Blocks.  Each block
     has a Block header followed by the block data. Block
     Data consists of Records. Records consist of Record
     Headers followed by Record Data.
   :=======================================================:
   |                                                       |
   |                 Block Header (24 bytes)               |
   |                                                       |
   |-------------------------------------------------------|
   |                                                       |
   |              Record Header (12 bytes)                 |
   |                                                       |
   |-------------------------------------------------------|
   |                                                       |
   |                  Record Data                          |
   |                                                       |
   |-------------------------------------------------------|
   |                                                       |
   |              Record Header (12 bytes)                 |
   |                                                       |
   |-------------------------------------------------------|
   |                                                       |
   |                       ...                             |
   Block Header: the first item in each block. The format is
     shown below.
   Partial Data block: occurs if the data from a previous
     block spills over to this block (the normal case except
     for the first block on a tape). However, this partial
         data block is always preceded by a record header.
   Record Header: identifies the Volume Session, the Stream
     and the following Record Data size. See below for format.
   Record data: arbitrary binary data.
                    Block Header Format BB02
   :=======================================================:
   |              CheckSum         (uint32_t)              |
   |-------------------------------------------------------|
   |              BlockSize        (uint32_t)              |
   |-------------------------------------------------------|
   |              BlockNumber      (uint32_t)              |
   |-------------------------------------------------------|
   |              &quot;BB02&quot;           (char [4])              |
   |-------------------------------------------------------|
   |              VolSessionId     (uint32_t)              |
   |-------------------------------------------------------|
   |              VolSessionTime   (uint32_t)              |
   :=======================================================:
   BBO2: Serves to identify the block as a
     Bacula block and also servers as a block format identifier
     should we ever need to change the format.
   BlockSize: is the size in bytes of the block. When reading
     back a block, if the BlockSize does not agree with the
     actual size read, Bacula discards the block.
   CheckSum: a checksum for the Block.
   BlockNumber: is the sequential block number on the tape.
   VolSessionId: a unique sequential number that is assigned
                 by the Storage Daemon to a particular Job.
                 This number is sequential since the start
                 of execution of the daemon.
   VolSessionTime: the time/date that the current execution
                 of the Storage Daemon started.  It assures
                 that the combination of VolSessionId and
                 VolSessionTime is unique for all jobs
                 written to the tape, even if there was a
                 machine crash between two writes.
                  Record Header Format BB02
   :=======================================================:
   |              FileIndex        (int32_t)               |
   |-------------------------------------------------------|
   |              Stream           (int32_t)               |
   |-------------------------------------------------------|
   |              DataSize         (uint32_t)              |
   :=======================================================:
   FileIndex: a sequential file number within a job.  The
                 Storage daemon enforces this index to be
                 greater than zero and sequential.  Note,
                 however, that the File daemon may send
                 multiple Streams for the same FileIndex.
                 The Storage Daemon uses negative FileIndices
                 to identify Session Start and End labels
                 as well as the End of Volume labels.
   Stream: defined by the File daemon and is intended to be
                 used to identify separate parts of the data
                 saved for each file (attributes, file data,
                 ...).  The Storage Daemon has no idea of
                 what a Stream is or what it contains.
   DataSize: the size in bytes of the binary data record
                 that follows the Session Record header.
                 The Storage Daemon has no idea of the
                 actual contents of the binary data record.
                 For standard Unix files, the data record
                 typically contains the file attributes or
                 the file data.  For a sparse file
                 the first 64 bits of the data contains
                 the storage address for the data block.
                       Volume Label
   :=======================================================:
   |              Id               (32 bytes)              |
   |-------------------------------------------------------|
   |              VerNum           (uint32_t)              |
   |-------------------------------------------------------|
   |              label_date       (float64_t)             |
   |              label_btime      (btime_t VerNum 11      |
   |-------------------------------------------------------|
   |              label_time       (float64_t)             |
   |              write_btime      (btime_t VerNum 11      |
   |-------------------------------------------------------|
   |              write_date       (float64_t)             |
   |                  0            (float64_t) VerNum 11   |
   |-------------------------------------------------------|
   |              write_time       (float64_t)             |
   |                  0            (float64_t) VerNum 11   |
   |-------------------------------------------------------|
   |              VolName          (128 bytes)             |
   |-------------------------------------------------------|
   |              PrevVolName      (128 bytes)             |
   |-------------------------------------------------------|
   |              PoolName         (128 bytes)             |
   |-------------------------------------------------------|
   |              PoolType         (128 bytes)             |
   |-------------------------------------------------------|
   |              MediaType        (128 bytes)             |
   |-------------------------------------------------------|
   |              HostName         (128 bytes)             |
   |-------------------------------------------------------|
   |              LabelProg        (32 bytes)              |
   |-------------------------------------------------------|
   |              ProgVersion      (32 bytes)              |
   |-------------------------------------------------------|
   |              ProgDate         (32 bytes)              |
   |-------------------------------------------------------|
   :=======================================================:

   Id: 32 byte Bacula identifier &quot;Bacula 1.0 immortal\n&quot;
   (old version also recognized:)
   Id: 32 byte Bacula identifier &quot;Bacula 0.9 mortal\n&quot;
   LabelType (Saved in the FileIndex of the Header record).
       PRE_LABEL -1    Volume label on unwritten tape
       VOL_LABEL -2    Volume label after tape written
       EOM_LABEL -3    Label at EOM (not currently implemented)
       SOS_LABEL -4    Start of Session label (format given below)
       EOS_LABEL -5    End of Session label (format given below)
   VerNum: 11
   label_date: Julian day tape labeled
   label_time: Julian time tape labeled
   write_date: Julian date tape first used (data written)
   write_time: Julian time tape first used (data written)
   VolName: &quot;Physical&quot; Volume name
   PrevVolName: The VolName of the previous tape (if this tape is
                a continuation of the previous one).
   PoolName: Pool Name
   PoolType: Pool Type
   MediaType: Media Type
   HostName: Name of host that is first writing the tape
   LabelProg: Name of the program that labeled the tape
   ProgVersion: Version of the label program
   ProgDate: Date Label program built
                       Session Label
   :=======================================================:
   |              Id               (32 bytes)              |
   |-------------------------------------------------------|
   |              VerNum           (uint32_t)              |
   |-------------------------------------------------------|
   |              JobId            (uint32_t)              |
   |-------------------------------------------------------|
   |              write_btime      (btime_t)   VerNum 11   |
   |-------------------------------------------------------|
   |                 0             (float64_t) VerNum 11   |
   |-------------------------------------------------------|
   |              PoolName         (128 bytes)             |
   |-------------------------------------------------------|
   |              PoolType         (128 bytes)             |
   |-------------------------------------------------------|
   |              JobName          (128 bytes)             |
   |-------------------------------------------------------|
   |              ClientName       (128 bytes)             |
   |-------------------------------------------------------|
   |              Job              (128 bytes)             |
   |-------------------------------------------------------|
   |              FileSetName      (128 bytes)             |
   |-------------------------------------------------------|
   |              JobType          (uint32_t)              |
   |-------------------------------------------------------|
   |              JobLevel         (uint32_t)              |
   |-------------------------------------------------------|
   |              FileSetMD5       (50 bytes)   VerNum 11  |
   |-------------------------------------------------------|
           Additional fields in End Of Session Label
   |-------------------------------------------------------|
   |              JobFiles         (uint32_t)              |
   |-------------------------------------------------------|
   |              JobBytes         (uint32_t)              |
   |-------------------------------------------------------|
   |              start_block      (uint32_t)              |
   |-------------------------------------------------------|
   |              end_block        (uint32_t)              |
   |-------------------------------------------------------|
   |              start_file       (uint32_t)              |
   |-------------------------------------------------------|
   |              end_file         (uint32_t)              |
   |-------------------------------------------------------|
   |              JobErrors        (uint32_t)              |
   |-------------------------------------------------------|
   |              JobStatus        (uint32_t) VerNum 11    |
   :=======================================================:
   * =&gt; fields deprecated
   Id: 32 byte Bacula Identifier &quot;Bacula 1.0 immortal\n&quot;
   LabelType (in FileIndex field of Header):
       EOM_LABEL -3     Label at EOM
       SOS_LABEL -4     Start of Session label
       EOS_LABEL -5     End of Session label
   VerNum: 11
   JobId: JobId
   write_btime: Bacula time/date this tape record written
   write_date: Julian date tape this record written - deprecated
   write_time: Julian time tape this record written - deprecated.
   PoolName: Pool Name
   PoolType: Pool Type
   MediaType: Media Type
   ClientName: Name of File daemon or Client writing this session
               Not used for EOM_LABEL.</code></pre>
<h2 id="unix-file-attributes">Unix File Attributes</h2>
<p>The Unix File Attributes packet consists of the following:</p>
<p><span>&lt;</span>File-Index<span>&gt;</span> <span>&lt;</span>Type<span>&gt;</span> <span>&lt;</span>Filename<span>&gt;</span>@<span>&lt;</span>File-Attributes<span>&gt;</span>@<span>&lt;</span>Link<span>&gt;</span> @<span>&lt;</span>Extended-Attributes@<span>&gt;</span> where</p>
<dl>
<dt>@</dt>
<dd><p>represents a byte containing a binary zero.</p>
</dd>
<dt>FileIndex</dt>
<dd><p>is the sequential file index starting from one assigned by the File daemon.</p>
</dd>
<dt>Type</dt>
<dd><p>is one of the following:</p>
<pre><code>#define FT_LNKSAVED   1    /* hard link to file already saved */
#define FT_REGE       2    /* Regular file but empty */
#define FT_REG        3    /* Regular file */
#define FT_LNK        4    /* Soft Link */
#define FT_DIR        5    /* Directory */
#define FT_SPEC       6    /* Special file -- chr, blk, fifo, sock */
#define FT_NOACCESS   7    /* Not able to access */
#define FT_NOFOLLOW   8    /* Could not follow link */
#define FT_NOSTAT     9    /* Could not stat file */
#define FT_NOCHG     10    /* Incremental option, file not changed */
#define FT_DIRNOCHG  11    /* Incremental option, directory not changed */
#define FT_ISARCH    12    /* Trying to save archive file */
#define FT_NORECURSE 13    /* No recursion into directory */
#define FT_NOFSCHG   14    /* Different file system, prohibited */
#define FT_NOOPEN    15    /* Could not open directory */
#define FT_RAW       16    /* Raw block device */
#define FT_FIFO      17    /* Raw fifo device */</code></pre>
</dd>
<dt>Filename</dt>
<dd><p>is the fully qualified filename.</p>
</dd>
<dt>File-Attributes</dt>
<dd><p>consists of the 13 fields of the stat() buffer in ASCII base64 format separated by spaces. These fields and their meanings are shown below. This stat() packet is in Unix format, and MUST be provided (constructed) for ALL systems.</p>
</dd>
<dt>Link</dt>
<dd><p>when the FT code is FT_LNK or FT_LNKSAVED, the item in question is a Unix link, and this field contains the fully qualified link name. When the FT code is not FT_LNK or FT_LNKSAVED, this field is null.</p>
</dd>
<dt>Extended-Attributes</dt>
<dd><p>The exact format of this field is operating system dependent. It contains additional or extended attributes of a system dependent nature. Currently, this field is used only on WIN32 systems where it contains a ASCII base64 representation of the WIN32_FILE_ATTRIBUTE_DATA structure as defined by Windows. The fields in the base64 representation of this structure are like the File-Attributes separated by spaces.</p>
</dd>
</dl>
<p>The File-attributes consist of the following:</p>
<p><span>|p<span>0.6in</span>|p<span>0.7in</span>|p<span>1in</span>|p<span>1in</span>|p<span>1.4in</span>|</span> &amp; &amp; &amp; &amp;<br /> &amp; <span>st_dev </span> &amp; <span>Device number of filesystem </span> &amp; <span>Drive number </span> &amp; <span>vRefNum </span><br /> &amp; <span>st_ino </span> &amp; <span>Inode number </span> &amp; <span>Always 0 </span> &amp; <span>fileID/dirID </span><br /> &amp; <span>st_mode </span> &amp; <span>File mode </span> &amp; <span>File mode </span> &amp; <span>777 dirs/apps; 666 docs; 444 locked docs </span><br /> &amp; <span>st_nlink </span> &amp; <span>Number of links to the file </span> &amp; <span>Number of link (only on NTFS) </span> &amp; <span>Always 1 </span><br /> &amp; <span>st_uid </span> &amp; <span>Owner ID </span> &amp; <span>Always 0 </span> &amp; <span>Always 0 </span><br /> &amp; <span>st_gid </span> &amp; <span>Group ID </span> &amp; <span>Always 0 </span> &amp; <span>Always 0 </span><br /> &amp; <span>st_rdev </span> &amp; <span>Device ID for special files </span> &amp; <span>Drive No. </span> &amp; <span>Always 0 </span><br /> &amp; <span>st_size </span> &amp; <span>File size in bytes </span> &amp; <span>File size in bytes </span> &amp; <span>Data fork file size in bytes </span><br /> &amp; <span>st_blksize </span> &amp; <span>Preferred block size </span> &amp; <span>Always 0 </span> &amp; <span>Preferred block size </span><br /> &amp; <span>st_blocks </span> &amp; <span>Number of blocks allocated </span> &amp; <span>Always 0 </span> &amp; <span>Number of blocks allocated </span><br /> &amp; <span>st_atime </span> &amp; <span>Last access time since epoch </span> &amp; <span>Last access time since epoch </span> &amp; <span>Last access time -66 years </span><br /> &amp; <span>st_mtime </span> &amp; <span>Last modify time since epoch </span> &amp; <span>Last modify time since epoch </span> &amp; <span>Last access time -66 years </span><br /> &amp; <span>st_ctime </span> &amp; <span>Inode change time since epoch </span> &amp; <span>File create time since epoch </span> &amp; <span>File create time -66 years</span><br /> Old Depreciated Tape Format —————————</p>
<p>The format of the Block Header (version 1.26 and earlier) is:</p>
<pre><code>   uint32_t CheckSum;      /* Block check sum */
   uint32_t BlockSize;     /* Block byte size including the header */
   uint32_t BlockNumber;   /* Block number */
   char ID[4] = &quot;BB01&quot;;    /* Identification and block level */</code></pre>
<p>The format of the Record Header (version 1.26 or earlier) is:</p>
<pre><code>  uint32_t VolSessionId;    /* Unique ID for this session */
  uint32_t VolSessionTime;  /* Start time/date of session */
  int32_t FileIndex;        /* File index supplied by File daemon */
  int32_t Stream;           /* Stream number supplied by File daemon */
  uint32_t DataSize;        /* size of following data record in bytes */

               Current Bacula Tape Format
                     6 June 2001
           Version BB01 is the old deprecated format.
   A Bacula tape is composed of tape Blocks.  Each block
     has a Block header followed by the block data. Block
     Data consists of Records. Records consist of Record
     Headers followed by Record Data.
   :=======================================================:
   |                                                       |
   |                 Block Header                          |
   |                 (16 bytes version BB01)               |
   |-------------------------------------------------------|
   |                                                       |
   |              Record Header                            |
   |               (20 bytes version BB01)                 |
   |-------------------------------------------------------|
   |                                                       |
   |                  Record Data                          |
   |                                                       |
   |-------------------------------------------------------|
   |                                                       |
   |              Record Header                            |
   |               (20 bytes version BB01)                 |
   |-------------------------------------------------------|
   |                                                       |
   |                       ...                             |
   Block Header: the first item in each block. The format is
     shown below.
   Partial Data block: occurs if the data from a previous
     block spills over to this block (the normal case except
     for the first block on a tape). However, this partial
         data block is always preceded by a record header.
   Record Header: identifies the Volume Session, the Stream
     and the following Record Data size. See below for format.
   Record data: arbitrary binary data.
                    Block Header Format BB01 (deprecated)
   :=======================================================:
   |              CheckSum         (uint32_t)              |
   |-------------------------------------------------------|
   |              BlockSize        (uint32_t)              |
   |-------------------------------------------------------|
   |              BlockNumber      (uint32_t)              |
   |-------------------------------------------------------|
   |              &quot;BB01&quot;           (char [4])              |
   :=======================================================:
   BBO1: Serves to identify the block as a
     Bacula block and also servers as a block format identifier
     should we ever need to change the format.
   BlockSize: is the size in bytes of the block. When reading
     back a block, if the BlockSize does not agree with the
     actual size read, Bacula discards the block.
   CheckSum: a checksum for the Block.
   BlockNumber: is the sequential block number on the tape.
   VolSessionId: a unique sequential number that is assigned
                 by the Storage Daemon to a particular Job.
                 This number is sequential since the start
                 of execution of the daemon.
   VolSessionTime: the time/date that the current execution
                 of the Storage Daemon started.  It assures
                 that the combination of VolSessionId and
                 VolSessionTime is unique for all jobs
                 written to the tape, even if there was a
                 machine crash between two writes.
                  Record Header Format BB01 (deprecated)
   :=======================================================:
   |              VolSessionId     (uint32_t)              |
   |-------------------------------------------------------|
   |              VolSessionTime   (uint32_t)              |
   |-------------------------------------------------------|
   |              FileIndex        (int32_t)               |
   |-------------------------------------------------------|
   |              Stream           (int32_t)               |
   |-------------------------------------------------------|
   |              DataSize         (uint32_t)              |
   :=======================================================:
   VolSessionId: a unique sequential number that is assigned
                 by the Storage Daemon to a particular Job.
                 This number is sequential since the start
                 of execution of the daemon.
   VolSessionTime: the time/date that the current execution
                 of the Storage Daemon started.  It assures
                 that the combination of VolSessionId and
                 VolSessionTime is unique for all jobs
                 written to the tape, even if there was a
                 machine crash between two writes.
   FileIndex: a sequential file number within a job.  The
                 Storage daemon enforces this index to be
                 greater than zero and sequential.  Note,
                 however, that the File daemon may send
                 multiple Streams for the same FileIndex.
                 The Storage Daemon uses negative FileIndices
                 to identify Session Start and End labels
                 as well as the End of Volume labels.
   Stream: defined by the File daemon and is intended to be
                 used to identify separate parts of the data
                 saved for each file (attributes, file data,
                 ...).  The Storage Daemon has no idea of
                 what a Stream is or what it contains.
   DataSize: the size in bytes of the binary data record
                 that follows the Session Record header.
                 The Storage Daemon has no idea of the
                 actual contents of the binary data record.
                 For standard Unix files, the data record
                 typically contains the file attributes or
                 the file data.  For a sparse file
                 the first 64 bits of the data contains
                 the storage address for the data block.
                       Volume Label
   :=======================================================:
   |              Id               (32 bytes)              |
   |-------------------------------------------------------|
   |              VerNum           (uint32_t)              |
   |-------------------------------------------------------|
   |              label_date       (float64_t)             |
   |-------------------------------------------------------|
   |              label_time       (float64_t)             |
   |-------------------------------------------------------|
   |              write_date       (float64_t)             |
   |-------------------------------------------------------|
   |              write_time       (float64_t)             |
   |-------------------------------------------------------|
   |              VolName          (128 bytes)             |
   |-------------------------------------------------------|
   |              PrevVolName      (128 bytes)             |
   |-------------------------------------------------------|
   |              PoolName         (128 bytes)             |
   |-------------------------------------------------------|
   |              PoolType         (128 bytes)             |
   |-------------------------------------------------------|
   |              MediaType        (128 bytes)             |
   |-------------------------------------------------------|
   |              HostName         (128 bytes)             |
   |-------------------------------------------------------|
   |              LabelProg        (32 bytes)              |
   |-------------------------------------------------------|
   |              ProgVersion      (32 bytes)              |
   |-------------------------------------------------------|
   |              ProgDate         (32 bytes)              |
   |-------------------------------------------------------|
   :=======================================================:

   Id: 32 byte Bacula identifier &quot;Bacula 1.0 immortal\n&quot;
   (old version also recognized:)
   Id: 32 byte Bacula identifier &quot;Bacula 0.9 mortal\n&quot;
   LabelType (Saved in the FileIndex of the Header record).
       PRE_LABEL -1    Volume label on unwritten tape
       VOL_LABEL -2    Volume label after tape written
       EOM_LABEL -3    Label at EOM (not currently implemented)
       SOS_LABEL -4    Start of Session label (format given below)
       EOS_LABEL -5    End of Session label (format given below)
   label_date: Julian day tape labeled
   label_time: Julian time tape labeled
   write_date: Julian date tape first used (data written)
   write_time: Julian time tape first used (data written)
   VolName: &quot;Physical&quot; Volume name
   PrevVolName: The VolName of the previous tape (if this tape is
                a continuation of the previous one).
   PoolName: Pool Name
   PoolType: Pool Type
   MediaType: Media Type
   HostName: Name of host that is first writing the tape
   LabelProg: Name of the program that labeled the tape
   ProgVersion: Version of the label program
   ProgDate: Date Label program built
                       Session Label
   :=======================================================:
   |              Id               (32 bytes)              |
   |-------------------------------------------------------|
   |              VerNum           (uint32_t)              |
   |-------------------------------------------------------|
   |              JobId            (uint32_t)              |
   |-------------------------------------------------------|
   |             *write_date       (float64_t) VerNum 10   |
   |-------------------------------------------------------|
   |             *write_time       (float64_t) VerNum 10   |
   |-------------------------------------------------------|
   |              PoolName         (128 bytes)             |
   |-------------------------------------------------------|
   |              PoolType         (128 bytes)             |
   |-------------------------------------------------------|
   |              JobName          (128 bytes)             |
   |-------------------------------------------------------|
   |              ClientName       (128 bytes)             |
   |-------------------------------------------------------|
   |              Job              (128 bytes)             |
   |-------------------------------------------------------|
   |              FileSetName      (128 bytes)             |
   |-------------------------------------------------------|
   |              JobType          (uint32_t)              |
   |-------------------------------------------------------|
   |              JobLevel         (uint32_t)              |
   |-------------------------------------------------------|
   |              FileSetMD5       (50 bytes)   VerNum 11  |
   |-------------------------------------------------------|
           Additional fields in End Of Session Label
   |-------------------------------------------------------|
   |              JobFiles         (uint32_t)              |
   |-------------------------------------------------------|
   |              JobBytes         (uint32_t)              |
   |-------------------------------------------------------|
   |              start_block      (uint32_t)              |
   |-------------------------------------------------------|
   |              end_block        (uint32_t)              |
   |-------------------------------------------------------|
   |              start_file       (uint32_t)              |
   |-------------------------------------------------------|
   |              end_file         (uint32_t)              |
   |-------------------------------------------------------|
   |              JobErrors        (uint32_t)              |
   |-------------------------------------------------------|
   |              JobStatus        (uint32_t) VerNum 11    |
   :=======================================================:
   * =&gt; fields deprecated
   Id: 32 byte Bacula Identifier &quot;Bacula 1.0 immortal\n&quot;
   LabelType (in FileIndex field of Header):
       EOM_LABEL -3     Label at EOM
       SOS_LABEL -4     Start of Session label
       EOS_LABEL -5     End of Session label
   VerNum: 11
   JobId: JobId
   write_btime: Bacula time/date this tape record written
   write_date: Julian date tape this record written - deprecated
   write_time: Julian time tape this record written - deprecated.
   PoolName: Pool Name
   PoolType: Pool Type
   MediaType: Media Type
   ClientName: Name of File daemon or Client writing this session
               Not used for EOM_LABEL.</code></pre>
<p>Bacula Porting Notes {#_ChapterStart1} ====================</p>
<p>This document is intended mostly for developers who wish to port Bacula to a system that is not <span><strong>officially</strong></span> supported.</p>
<p>It is hoped that Bacula clients will eventually run on every imaginable system that needs backing up (perhaps even a Palm). It is also hoped that the Bacula Directory and Storage daemons will run on every system capable of supporting them.</p>
<h2 id="porting-requirements">Porting Requirements</h2>
<p>In General, the following holds true:</p>
<ul>
<li><p><span><strong>Bacula</strong></span> has been compiled and run on Linux RedHat, FreeBSD, and Solaris systems.</p></li>
<li><p>In addition, clients exist on Win32, and Irix</p></li>
<li><p>It requires GNU C++ to compile. You can try with other compilers, but you are on your own. The Irix client is built with the Irix complier, but, in general, you will need GNU.</p></li>
<li><p>Your compiler must provide support for 64 bit signed and unsigned integers.</p></li>
<li><p>You will need a recent copy of the <span><strong>autoconf</strong></span> tools loaded on your system (version 2.13 or later). The <span><strong>autoconf</strong></span> tools are used to build the configuration program, but are not part of the Bacula source distribution.</p></li>
<li><p>There are certain third party packages that Bacula needs. Except for MySQL, they can all be found in the <span><strong>depkgs</strong></span> and <span><strong>depkgs1</strong></span> releases.</p></li>
<li><p>To build the Win32 binaries, we use Microsoft VC++ standard 2003. Please see the instructions in bacula-source/src/win32/README.win32 for more details. If you want to use VC++ Express, please see README.vc8. Our build is done under the most recent version of Cygwin, but Cygwin is not used in the Bacula binaries that are produced. Unfortunately, we do not have the resources to help you build your own version of the Win32 FD, so you are pretty much on your own. You can ask the bacula-devel list for help, but please don’t expect much.</p></li>
<li><p><span><strong>Bacula</strong></span> requires a good implementation of pthreads to work.</p></li>
<li><p>The source code has been written with portability in mind and is mostly POSIX compatible. Thus porting to any POSIX compatible operating system should be relatively easy.</p></li>
</ul>
<h2 id="steps-to-take-for-porting">Steps to Take for Porting</h2>
<ul>
<li><p>The first step is to ensure that you have version 2.13 or later of the <span><strong>autoconf</strong></span> tools loaded. You can skip this step, but making changes to the configuration program will be difficult or impossible.</p></li>
<li><p>The run a <span><strong>./configure</strong></span> command in the main source directory and examine the output. It should look something like the following:</p>
<pre><code>Configuration on Mon Oct 28 11:42:27 CET 2002:
  Host:                        i686-pc-linux-gnu -- redhat 7.3
  Bacula version:              1.27 (26 October 2002)
  Source code location:        .
  Install binaries:            /sbin
  Install config files:        /etc/bacula
  C Compiler:                  gcc
  C++ Compiler:                c++
  Compiler flags:              -g -O2
  Linker flags:
  Libraries:                   -lpthread
  Statically Linked Tools:     no
  Database found:              no
  Database type:               Internal
  Database lib:
  Job Output Email:            root@localhost
  Traceback Email:             root@localhost
  SMTP Host Address:           localhost
  Director Port                9101
  File daemon Port             9102
  Storage daemon Port          9103
  Working directory            /etc/bacula/working
  SQL binaries Directory
  Large file support:          yes
  readline support:            yes
  cweb support:                yes /home/kern/bacula/depkgs/cweb
  TCP Wrappers support:        no
  ZLIB support:                yes
  enable-smartalloc:           yes
  enable-gnome:                no
  gmp support:                 yes</code></pre>
<p>The details depend on your system. The first thing to check is that it properly identified your host on the <span><strong>Host:</strong></span> line. The first part (added in version 1.27) is the GNU four part identification of your system. The part after the – is your system and the system version. Generally, if your system is not yet supported, you must correct these.</p></li>
<li><p>If the <span><strong>./configure</strong></span> does not function properly, you must determine the cause and fix it. Generally, it will be because some required system routine is not available on your machine.</p></li>
<li><p>To correct problems with detection of your system type or with routines and libraries, you must edit the file <span><strong><span>&lt;</span>bacula-src<span>&gt;</span>/autoconf/configure.in</strong></span>. This is the “source” from which <span><strong>configure</strong></span> is built. In general, most of the changes for your system will be made in <span><strong>autoconf/aclocal.m4</strong></span> in the routine <span><strong>BA_CHECK_OPSYS</strong></span> or in the routine <span><strong>BA_CHECK_OPSYS_DISTNAME</strong></span>. I have already added the necessary code for most systems, but if yours shows up as <span><strong>unknown</strong></span> you will need to make changes. Then as mentioned above, you will need to set a number of system dependent items in <span><strong>configure.in</strong></span> in the <span><strong>case</strong></span> statement at approximately line 1050 (depending on the Bacula release).</p></li>
<li><p>The items to in the case statement that corresponds to your system are the following:</p>
<ul>
<li><p>DISTVER – set to the version of your operating system. Typically some form of <span><strong>uname</strong></span> obtains it.</p></li>
<li><p>TAPEDRIVE – the default tape drive. Not too important as the user can set it as an option.</p></li>
<li><p>PSCMD – set to the <span><strong>ps</strong></span> command that will provide the PID in the first field and the program name in the second field. If this is not set properly, the <span><strong>bacula stop</strong></span> script will most likely not be able to stop Bacula in all cases.</p></li>
<li><p>hostname – command to return the base host name (non-qualified) of your system. This is generally the machine name. Not too important as the user can correct this in his configuration file.</p></li>
<li><p>CFLAGS – set any special compiler flags needed. Many systems need a special flag to make pthreads work. See cygwin for an example.</p></li>
<li><p>LDFLAGS – set any special loader flags. See cygwin for an example.</p></li>
<li><p>PTHREAD_LIB – set for any special pthreads flags needed during linking. See freebsd as an example.</p></li>
<li><p>lld – set so that a “long long int” will be properly edited in a printf() call.</p></li>
<li><p>llu – set so that a “long long unsigned” will be properly edited in a printf() call.</p></li>
<li><p>PFILES – set to add any files that you may define is your platform subdirectory. These files are used for installation of automatic system startup of Bacula daemons.</p></li>
</ul></li>
<li><p>To rebuild a new version of <span><strong>configure</strong></span> from a changed <span><strong>autoconf/configure.in</strong></span> you enter <span><strong>make configure</strong></span> in the top level Bacula source directory. You must have done a ./configure prior to trying to rebuild the configure script or it will get into an infinite loop.</p></li>
<li><p>If the <span><strong>make configure</strong></span> gets into an infinite loop, ctl-c it, then do <span><strong>./configure</strong></span> (no options are necessary) and retry the <span><strong>make configure</strong></span>, which should now work.</p></li>
<li><p>To rebuild <span><strong>configure</strong></span> you will need to have <span><strong>autoconf</strong></span> version 2.57-3 or higher loaded. Older versions of autoconf will complain about unknown or bad options, and won’t work.</p></li>
<li><p>After you have a working <span><strong>configure</strong></span> script, you may need to make a few system dependent changes to the way Bacula works. Generally, these are done in <span><strong>src/baconfig.h</strong></span>. You can find a few examples of system dependent changes toward the end of this file. For example, on Irix systems, there is no definition for <span><strong>socklen_t</strong></span>, so it is made in this file. If your system has structure alignment requirements, check the definition of BALIGN in this file. Currently, all Bacula allocated memory is aligned on a <span><strong>double</strong></span> boundary.</p></li>
<li><p>If you are having problems with Bacula’s type definitions, you might look at <span><strong>src/bc_types.h</strong></span> where all the types such as <span><strong>uint32_t</strong></span>, <span><strong>uint64_t</strong></span>, etc. that Bacula uses are defined.</p></li>
</ul>
<p>Implementing a GUI Interface {#_ChapterStart .unnumbered} ============================</p>
<h2 id="general-4">General</h2>
<p>This document is intended mostly for developers who wish to develop a new GUI interface to <span><strong>Bacula</strong></span>.</p>
<h3 id="minimal-code-in-console-program">Minimal Code in Console Program</h3>
<p>Until now, I have kept all the Catalog code in the Directory (with the exception of dbcheck and bscan). This is because at some point I would like to add user level security and access. If we have code spread everywhere such as in a GUI this will be more difficult. The other advantage is that any code you add to the Director is automatically available to both the tty console program and the WX program. The major disadvantage is it increases the size of the code – however, compared to Networker the Bacula Director is really tiny.</p>
<h3 id="gui-interface-is-difficult">GUI Interface is Difficult</h3>
<p>Interfacing to an interactive program such as Bacula can be very difficult because the interfacing program must interpret all the prompts that may come. This can be next to impossible. There are are a number of ways that Bacula is designed to facilitate this:</p>
<ul>
<li><p>The Bacula network protocol is packet based, and thus pieces of information sent can be ASCII or binary.</p></li>
<li><p>The packet interface permits knowing where the end of a list is.</p></li>
<li><p>The packet interface permits special “signals” to be passed rather than data.</p></li>
<li><p>The Director has a number of commands that are non-interactive. They all begin with a period, and provide things such as the list of all Jobs, list of all Clients, list of all Pools, list of all Storage, … Thus the GUI interface can get to virtually all information that the Director has in a deterministic way. See <span>&lt;</span>bacula-source<span>&gt;</span>/src/dird/ua_dotcmds.c for more details on this.</p></li>
<li><p>Most console commands allow all the arguments to be specified on the command line: e.g. <span><strong>run job=NightlyBackup level=Full</strong></span></p></li>
</ul>
<p>One of the first things to overcome is to be able to establish a conversation with the Director. Although you can write all your own code, it is probably easier to use the Bacula subroutines. The following code is used by the Console program to begin a conversation.</p>
<pre><code>static BSOCK *UA_sock = NULL;
static JCR *jcr;
...
  read-your-config-getting-address-and-pasword;
  UA_sock = bnet_connect(NULL, 5, 15, &quot;Director daemon&quot;, dir-&gt;address,
                          NULL, dir-&gt;DIRport, 0);
   if (UA_sock == NULL) {
      terminate_console(0);
      return 1;
   }
   jcr.dir_bsock = UA_sock;
   if (!authenticate_director(\&amp;jcr, dir)) {
      fprintf(stderr, &quot;ERR=%s&quot;, UA_sock-&gt;msg);
      terminate_console(0);
      return 1;
   }
   read_and_process_input(stdin, UA_sock);
   if (UA_sock) {
      bnet_sig(UA_sock, BNET_TERMINATE); /* send EOF */
      bnet_close(UA_sock);
   }
   exit 0;</code></pre>
<p>Then the read_and_process_input routine looks like the following:</p>
<pre><code>   get-input-to-send-to-the-Director;
   bnet_fsend(UA_sock, &quot;%s&quot;, input);
   stat = bnet_recv(UA_sock);
   process-output-from-the-Director;</code></pre>
<p>For a GUI program things will be a bit more complicated. Basically in the very inner loop, you will need to check and see if any output is available on the UA_sock. For an example, please take a look at the WX GUI interface code in:</p>
<h2 id="sec:bvfs">Bvfs API</h2>
<p>To help developers of restore GUI interfaces, we have added new <em>dot commands</em> that permit browsing the catalog in a very simple way.</p>
<p>Bat has now a bRestore panel that uses Bvfs to display files and directories.</p>
<p><img src="\idir%20bat-brestore" alt="image" /> [fig:batbrestore]</p>
<p>The Bvfs module works correctly with BaseJobs, Copy and Migration jobs.</p>
<p>This project was funded by Bacula Systems.</p>
<h3 id="general-notes" class="unnumbered">General notes</h3>
<ul>
<li><p>All fields are separated by a tab</p></li>
<li><p>You can specify <code>limit=</code> and <code>offset=</code> to list smoothly records in very big directories</p></li>
<li><p>All operations (except cache creation) are designed to run instantly</p></li>
<li><p>At this time, Bvfs works faster on PostgreSQL than MySQL catalog. If you can contribute new faster SQL queries we will be happy, else don’t complain about speed.</p></li>
<li><p>The cache creation is dependent of the number of directories. As Bvfs shares information accross jobs, the first creation can be slow</p></li>
<li><p>All fields are separated by a tab</p></li>
<li><p>Due to potential encoding problem, it’s advised to allways use pathid in queries.</p></li>
</ul>
<h3 id="get-dependent-jobs-from-a-given-jobid" class="unnumbered">Get dependent jobs from a given JobId</h3>
<p>Bvfs allows you to query the catalog against any combination of jobs. You can combine all Jobs and all FileSet for a Client in a single session.</p>
<p>To get all JobId needed to restore a particular job, you can use the <code>.bvfs_get_jobids</code> command.</p>
<pre><code>.bvfs_get_jobids jobid=num [all]

.bvfs_get_jobids jobid=10
1,2,5,10
.bvfs_get_jobids jobid=10 all
1,2,3,5,10</code></pre>
<p>In this example, a normal restore will need to use JobIds 1,2,5,10 to compute a complete restore of the system.</p>
<p>With the <code>all</code> option, the Director will use all defined FileSet for this client.</p>
<h3 id="generating-bvfs-cache" class="unnumbered">Generating Bvfs cache</h3>
<p>The <code>.bvfs_update</code> command computes the directory cache for jobs specified in argument, or for all jobs if unspecified.</p>
<pre><code>.bvfs_update [jobid=numlist]</code></pre>
<p>Example:</p>
<pre><code>.bvfs_update jobid=1,2,3</code></pre>
<p>You can run the cache update process in a RunScript after the catalog backup.</p>
<h3 id="get-all-versions-of-a-specific-file" class="unnumbered">Get all versions of a specific file</h3>
<p>Bvfs allows you to find all versions of a specific file for a given Client with the <code>.bvfs_version</code> command. To avoid problems with encoding, this function uses only PathId and FilenameId. The jobid argument is mandatory but unused.</p>
<pre><code>.bvfs_versions client=filedaemon pathid=num filenameid=num jobid=1
PathId FilenameId FileId JobId LStat Md5 VolName Inchanger
PathId FilenameId FileId JobId LStat Md5 VolName Inchanger
...</code></pre>
<p>Example:</p>
<pre><code>.bvfs_versions client=localhost-fd pathid=1 fnid=47 jobid=1
1  47  52  12  gD HRid IGk D Po Po A P BAA I A   /uPgWaxMgKZlnMti7LChyA  Vol1  1</code></pre>
<h3 id="list-directories" class="unnumbered">List directories</h3>
<p>Bvfs allows you to list directories in a specific path.</p>
<pre><code>.bvfs_lsdirs pathid=num path=/apath jobid=numlist limit=num offset=num
PathId  FilenameId  FileId  JobId  LStat  Path
PathId  FilenameId  FileId  JobId  LStat  Path
PathId  FilenameId  FileId  JobId  LStat  Path
...</code></pre>
<p>You need to <code>pathid</code> or <code>path</code>. Using <code>path=</code> will list “/” on Unix and all drives on Windows. If FilenameId is 0, the record listed is a directory.</p>
<pre><code>.bvfs_lsdirs pathid=4 jobid=1,11,12
4       0       0       0       A A A A A A A A A A A A A A     .
5       0       0       0       A A A A A A A A A A A A A A     ..
3       0       0       0       A A A A A A A A A A A A A A     regress/</code></pre>
<p>In this example, to list directories present in <code>regress/</code>, you can use</p>
<pre><code>.bvfs_lsdirs pathid=3 jobid=1,11,12
3       0       0       0       A A A A A A A A A A A A A A     .
4       0       0       0       A A A A A A A A A A A A A A     ..
2       0       0       0       A A A A A A A A A A A A A A     tmp/</code></pre>
<h3 id="list-files" class="unnumbered">List files</h3>
<p>Bvfs allows you to list files in a specific path.</p>
<pre><code>.bvfs_lsfiles pathid=num path=/apath jobid=numlist limit=num offset=num
PathId  FilenameId  FileId  JobId  LStat  Path
PathId  FilenameId  FileId  JobId  LStat  Path
PathId  FilenameId  FileId  JobId  LStat  Path
...</code></pre>
<p>You need to <code>pathid</code> or <code>path</code>. Using <code>path=</code> will list “/” on Unix and all drives on Windows. If FilenameId is 0, the record listed is a directory.</p>
<pre><code>.bvfs_lsfiles pathid=4 jobid=1,11,12
4       0       0       0       A A A A A A A A A A A A A A     .
5       0       0       0       A A A A A A A A A A A A A A     ..
1       0       0       0       A A A A A A A A A A A A A A     regress/</code></pre>
<p>In this example, to list files present in <code>regress/</code>, you can use</p>
<pre><code>.bvfs_lsfiles pathid=1 jobid=1,11,12
1   47   52   12    gD HRid IGk BAA I BMqcPH BMqcPE BMqe+t A     titi
1   49   53   12    gD HRid IGk BAA I BMqe/K BMqcPE BMqe+t B     toto
1   48   54   12    gD HRie IGk BAA I BMqcPH BMqcPE BMqe+3 A     tutu
1   45   55   12    gD HRid IGk BAA I BMqe/K BMqcPE BMqe+t B     ficheriro1.txt
1   46   56   12    gD HRie IGk BAA I BMqe/K BMqcPE BMqe+3 D     ficheriro2.txt</code></pre>
<h3 id="restore-set-of-files" class="unnumbered">Restore set of files</h3>
<p>Bvfs allows you to create a SQL table that contains files that you want to restore. This table can be provided to a restore command with the file option.</p>
<pre><code>.bvfs_restore fileid=numlist dirid=numlist hardlink=numlist path=b2num
OK
restore file=?b2num ...</code></pre>
<p>To include a directory (with <code>dirid</code>), Bvfs needs to run a query to select all files. This query could be time consuming.</p>
<p><code>hardlink</code> list is always composed of a serie of two numbers (jobid, fileindex). This information can be found in the LinkFI field of the LStat packet.</p>
<p>The <code>path</code> argument represents the name of the table that Bvfs will store results. The format of this table is <code>b2[0-9]+</code>. (Should start by b2 and followed by digits).</p>
<p>Example:</p>
<pre><code>.bvfs_restore fileid=1,2,3,4 hardlink=10,15,10,20 jobid=10 path=b20001
OK</code></pre>
<h3 id="cleanup-after-restore" class="unnumbered">Cleanup after Restore</h3>
<p>To drop the table used by the restore command, you can use the <code>.bvfs_cleanup</code> command.</p>
<pre><code>.bvfs_cleanup path=b20001</code></pre>
<h3 id="clearing-the-bvfs-cache" class="unnumbered">Clearing the BVFS Cache</h3>
<p>To clear the BVFS cache, you can use the <code>.bvfs_clear_cache</code> command.</p>
<pre><code>.bvfs_clear_cache yes
OK</code></pre>
<h1 id="tls-chaptertls">TLS {#<em>Chapter</em>TLS}</h1>
<p>Written by Landon Fuller</p>
<h2 id="introduction-to-tls">Introduction to TLS</h2>
<p>This patch includes all the back-end code necessary to add complete TLS data encryption support to Bacula. In addition, support for TLS in Console/Director communications has been added as a proof of concept. Adding support for the remaining daemons will be straight-forward. Supported features of this patchset include:</p>
<ul>
<li><p>Client/Server TLS Requirement Negotiation</p></li>
<li><p>TLSv1 Connections with Server and Client Certificate Validation</p></li>
<li><p>Forward Secrecy Support via Diffie-Hellman Ephemeral Keying</p></li>
</ul>
<p>This document will refer to both “server” and “client” contexts. These terms refer to the accepting and initiating peer, respectively.</p>
<p>Diffie-Hellman anonymous ciphers are not supported by this patchset. The use of DH anonymous ciphers increases the code complexity and places explicit trust upon the two-way Cram-MD5 implementation. Cram-MD5 is subject to known plaintext attacks, and is should be considered considerably less secure than PKI certificate-based authentication.</p>
<p>Appropriate autoconf macros have been added to detect and use OpenSSL. Two additional preprocessor defines have been added: <em>HAVE_TLS</em> and <em>HAVE_OPENSSL</em>. All changes not specific to OpenSSL rely on <em>HAVE_TLS</em>. OpenSSL-specific code is constrained to <em>src/lib/tls.c</em> to facilitate the support of alternative TLS implementations.</p>
<h2 id="new-configuration-directives">New Configuration Directives</h2>
<p>Additional configuration directives have been added to both the Console and Director resources. These new directives are defined as follows:</p>
<ul>
<li><p><em>(yes/no)</em> Enable TLS support.</p></li>
<li><p><em>(yes/no)</em> Require TLS connections.</p></li>
<li><p><em>(path)</em> Path to PEM encoded TLS certificate. Used as either a client or server certificate.</p></li>
<li><p><em>(path)</em> Path to PEM encoded TLS private key. Must correspond with the TLS certificate.</p></li>
<li><p><em>(yes/no)</em> Verify peer certificate. Instructs server to request and verify the client’s x509 certificate. Any client certificate signed by a known-CA will be accepted unless the TLS Allowed CN configuration directive is used. Not valid in a client context.</p></li>
<li><p><em>(string list)</em> Common name attribute of allowed peer certificates. If directive is specified, all client certificates will be verified against this list. This directive may be specified more than once. Not valid in a client context.</p></li>
<li><p><em>(path)</em> Path to PEM encoded TLS CA certificate(s). Multiple certificates are permitted in the file. One of <em>TLS CA Certificate File</em> or <em>TLS CA Certificate Dir</em> are required in a server context if is also specified, and are always required in a client context.</p></li>
<li><p><em>(path)</em> Path to TLS CA certificate directory. In the current implementation, certificates must be stored PEM encoded with OpenSSL-compatible hashes. One of <em>TLS CA Certificate File</em> or <em>TLS CA Certificate Dir</em> are required in a server context if <em>TLS Verify Peer</em> is also specified, and are always required in a client context.</p></li>
<li><p><em>(path)</em> Path to PEM encoded Diffie-Hellman parameter file. If this directive is specified, DH ephemeral keying will be enabled, allowing for forward secrecy of communications. This directive is only valid within a server context. To generate the parameter file, you may use openssl:</p>
<pre><code>openssl dhparam -out dh1024.pem -5 1024</code></pre></li>
</ul>
<h2 id="tls-api-implementation">TLS API Implementation</h2>
<p>To facilitate the use of additional TLS libraries, all OpenSSL-specific code has been implemented within <em>src/lib/tls.c</em>. In turn, a generic TLS API is exported.</p>
<h3 id="library-initialization-and-cleanup">Library Initialization and Cleanup</h3>
<pre><code>int init_tls (void);</code></pre>
<p>Performs TLS library initialization, including seeding of the PRNG. PRNG seeding has not yet been implemented for win32.</p>
<pre><code>int cleanup_tls (void);</code></pre>
<p>Performs TLS library cleanup.</p>
<h3 id="manipulating-tls-contexts">Manipulating TLS Contexts</h3>
<pre><code>TLS_CONTEXT  *new_tls_context (const char *ca_certfile,
        const char *ca_certdir, const char *certfile,
        const char *keyfile, const char *dhfile, bool verify_peer);</code></pre>
<p>Allocates and initalizes a new opaque <em>TLS_CONTEXT</em> structure. The <em>TLS_CONTEXT</em> structure maintains default TLS settings from which <em>TLS_CONNECTION</em> structures are instantiated. In the future the <em>TLS_CONTEXT</em> structure may be used to maintain the TLS session cache. <em>ca_certfile</em> and <em>ca_certdir</em> arguments are used to initialize the CA verification stores. The <em>certfile</em> and <em>keyfile</em> arguments are used to initialize the local certificate and private key. If <em>dhfile</em> is non-NULL, it is used to initialize Diffie-Hellman ephemeral keying. If <em>verify_peer</em> is <em>true</em> , client certificate validation is enabled.</p>
<pre><code>void free_tls_context (TLS_CONTEXT *ctx);</code></pre>
<p>Deallocated a previously allocated <em>TLS_CONTEXT</em> structure.</p>
<h3 id="performing-post-connection-verification">Performing Post-Connection Verification</h3>
<pre><code>bool tls_postconnect_verify_host (TLS_CONNECTION *tls, const char *host);</code></pre>
<p>Performs post-connection verification of the peer-supplied x509 certificate. Checks whether the <em>subjectAltName</em> and <em>commonName</em> attributes match the supplied <em>host</em> string. Returns <em>true</em> if there is a match, <em>false</em> otherwise.</p>
<pre><code>bool tls_postconnect_verify_cn (TLS_CONNECTION *tls, alist *verify_list);</code></pre>
<p>Performs post-connection verification of the peer-supplied x509 certificate. Checks whether the <em>commonName</em> attribute matches any strings supplied via the <em>verify_list</em> parameter. Returns <em>true</em> if there is a match, <em>false</em> otherwise.</p>
<h3 id="manipulating-tls-connections">Manipulating TLS Connections</h3>
<pre><code>TLS_CONNECTION *new_tls_connection (TLS_CONTEXT *ctx, int fd);</code></pre>
<p>Allocates and initializes a new <em>TLS_CONNECTION</em> structure with context <em>ctx</em> and file descriptor <em>fd</em>.</p>
<pre><code>void free_tls_connection (TLS_CONNECTION *tls);</code></pre>
<p>Deallocates memory associated with the <em>tls</em> structure.</p>
<pre><code>bool tls_bsock_connect (BSOCK *bsock);</code></pre>
<p>Negotiates a a TLS client connection via <em>bsock</em>. Returns <em>true</em> if successful, <em>false</em> otherwise. Will fail if there is a TLS protocol error or an invalid certificate is presented</p>
<pre><code>bool tls_bsock_accept (BSOCK *bsock);</code></pre>
<p>Accepts a TLS client connection via <em>bsock</em>. Returns <em>true</em> if successful, <em>false</em> otherwise. Will fail if there is a TLS protocol error or an invalid certificate is presented.</p>
<pre><code>bool tls_bsock_shutdown (BSOCK *bsock);</code></pre>
<p>Issues a blocking TLS shutdown request to the peer via <em>bsock</em>. This function may not wait for the peer’s reply.</p>
<pre><code>int tls_bsock_writen (BSOCK *bsock, char *ptr, int32_t nbytes);</code></pre>
<p>Writes <em>nbytes</em> from <em>ptr</em> via the <em>TLS_CONNECTION</em> associated with <em>bsock</em>. Due to OpenSSL’s handling of <em>EINTR</em>, <em>bsock</em> is set non-blocking at the start of the function, and restored to its original blocking state before the function returns. Less than <em>nbytes</em> may be written if an error occurs. The actual number of bytes written will be returned.</p>
<pre><code>int tls_bsock_readn (BSOCK *bsock, char *ptr, int32_t nbytes);</code></pre>
<p>Reads <em>nbytes</em> from the <em>TLS_CONNECTION</em> associated with <em>bsock</em> and stores the result in <em>ptr</em>. Due to OpenSSL’s handling of <em>EINTR</em>, <em>bsock</em> is set non-blocking at the start of the function, and restored to its original blocking state before the function returns. Less than <em>nbytes</em> may be read if an error occurs. The actual number of bytes read will be returned.</p>
<h2 id="bnet-api-changes">Bnet API Changes</h2>
<p>A minimal number of changes were required in the Bnet socket API. The BSOCK structure was expanded to include an associated TLS_CONNECTION structure, as well as a flag to designate the current blocking state of the socket. The blocking state flag is required for win32, where it does not appear possible to discern the current blocking state of a socket.</p>
<h3 id="negotiating-a-tls-connection">Negotiating a TLS Connection</h3>
<p><em>bnet_tls_server()</em> and <em>bnet_tls_client()</em> were both implemented using the new TLS API as follows:</p>
<pre><code>int bnet_tls_client(TLS_CONTEXT *ctx, BSOCK * bsock);</code></pre>
<p>Negotiates a TLS session via <em>bsock</em> using the settings from <em>ctx</em>. Returns 1 if successful, 0 otherwise.</p>
<pre><code>int bnet_tls_server(TLS_CONTEXT *ctx, BSOCK * bsock, alist *verify_list);</code></pre>
<p>Accepts a TLS client session via <em>bsock</em> using the settings from <em>ctx</em>. If <em>verify_list</em> is non-NULL, it is passed to <em>tls_postconnect_verify_cn()</em> for client certificate verification.</p>
<h3 id="manipulating-socket-blocking-state">Manipulating Socket Blocking State</h3>
<p>Three functions were added for manipulating the blocking state of a socket on both Win32 and Unix-like systems. The Win32 code was written according to the MSDN documentation, but has not been tested.</p>
<p>These functions are prototyped as follows:</p>
<pre><code>int bnet_set_nonblocking (BSOCK *bsock);</code></pre>
<p>Enables non-blocking I/O on the socket associated with <em>bsock</em>. Returns a copy of the socket flags prior to modification.</p>
<pre><code>int bnet_set_blocking (BSOCK *bsock);</code></pre>
<p>Enables blocking I/O on the socket associated with <em>bsock</em>. Returns a copy of the socket flags prior to modification.</p>
<pre><code>void bnet_restore_blocking (BSOCK *bsock, int flags);</code></pre>
<p>Restores blocking or non-blocking IO setting on the socket associated with <em>bsock</em>. The <em>flags</em> argument must be the return value of either <em>bnet_set_blocking()</em> or <em>bnet_restore_blocking()</em>.</p>
<h2 id="authentication-negotiation">Authentication Negotiation</h2>
<p>Backwards compatibility with the existing SSL negotiation hooks implemented in src/lib/cram-md5.c have been maintained. The <em>cram_md5_get_auth()</em> function has been modified to accept an integer pointer argument, tls_remote_need. The TLS requirement advertised by the remote host is returned via this pointer.</p>
<p>After exchanging cram-md5 authentication and TLS requirements, both the client and server independently decide whether to continue:</p>
<pre><code>if (!cram_md5_get_auth(dir, password, &amp;tls_remote_need) ||
        !cram_md5_auth(dir, password, tls_local_need)) {
[snip]
/* Verify that the remote host is willing to meet our TLS requirements */
if (tls_remote_need &lt; tls_local_need &amp;&amp; tls_local_need != BNET_TLS_OK &amp;&amp;
        tls_remote_need != BNET_TLS_OK) {
   sendit(_(&quot;Authorization problem:&quot;
            &quot; Remote server did not advertise required TLS support.\n&quot;));
   auth_success = false;
   goto auth_done;
}

/* Verify that we are willing to meet the remote host&#39;s requirements */
if (tls_remote_need &gt; tls_local_need &amp;&amp; tls_local_need != BNET_TLS_OK &amp;&amp;
        tls_remote_need != BNET_TLS_OK) {
   sendit(_(&quot;Authorization problem:&quot;
            &quot; Remote server requires TLS.\n&quot;));
   auth_success = false;
   goto auth_done;
}</code></pre>
<p>Bacula Regression Testing {#_ChapterStart8} =========================</p>
<h2 id="setting-up-regession-testing">Setting up Regession Testing</h2>
<p>This document is intended mostly for developers who wish to ensure that their changes to Bacula don’t introduce bugs in the base code. However, you don’t need to be a developer to run the regression scripts, and we recommend them before putting your system into production, and before each upgrade, especially if you build from source code. They are simply shell scripts that drive Bacula through bconsole and then typically compare the input and output with <span><strong>diff</strong></span>.</p>
<p>You can find the existing regression scripts in the Bacula developer’s <span><strong>git</strong></span> repository on SourceForge. We strongly recommend that you <span><strong>clone</strong></span> the repository because afterwards, you can easily get pull the updates that have been made.</p>
<p>To get started, we recommend that you create a directory named <span><strong>bacula</strong></span>, under which you will put the current source code and the current set of regression scripts. Below, we will describe how to set this up.</p>
<p>The top level directory that we call <span><strong>bacula</strong></span> can be named anything you want. Note, all the standard regression scripts run as non-root and can be run on the same machine as a production Bacula system (the developers run it this way).</p>
<p>To create the directory structure for the current trunk and to clone the repository, do the following (note, we assume you are working in your home directory in a non-root account):</p>
<pre><code>git clone http://git.bacula.org/bacula bacula</code></pre>
<p>This will create the directory <span><strong>bacula</strong></span> and populate it with three directories: <span><strong>bacula</strong></span>, <span><strong>gui</strong></span>, and <span><strong>regress</strong></span>. <span><strong>bacula</strong></span> contains the Bacula source code; <span><strong>gui</strong></span> contains certain gui programs that you will not need, and <span><strong>regress</strong></span> contains all the regression scripts. The above should be needed only once. Thereafter to update to the latest code, you do:</p>
<pre><code>cd bacula
git pull</code></pre>
<p>If you want to test with SQLite and it is not installed on your system, you will need to download the latest depkgs release from Source Forge and unpack it into <span><strong>depkgs</strong></span>, then simply:</p>
<pre><code>cd depkgs
make</code></pre>
<p>There are two different aspects of regression testing that this document will discuss: 1. Running the Regression Script, 2. Writing a Regression test.</p>
<h2 id="running-the-regression-script">Running the Regression Script</h2>
<p>There are a number of different tests that may be run, such as: the standard set that uses disk Volumes and runs under any userid; a small set of tests that write to tape; another set of tests where you must be root to run them. Normally, I run all my tests as non-root and very rarely run the root tests. The tests vary in length, and running the full tests including disk based testing, tape based testing, autochanger based testing, and multiple drive autochanger based testing can take 3 or 4 hours.</p>
<h3 id="setting-the-configuration-parameters">Setting the Configuration Parameters</h3>
<p>There is nothing you need to change in the source directory.</p>
<p>To begin:</p>
<pre><code>cd bacula/regress</code></pre>
<p>The very first time you are going to run the regression scripts, you will need to create a custom config file for your system. We suggest that you start by:</p>
<pre><code>cp prototype.conf config</code></pre>
<p>Then you can edit the <span><strong>config</strong></span> file directly.</p>
<pre><code># Where to get the source to be tested
BACULA_SOURCE=&quot;${HOME}/bacula/bacula&quot;

# Where to send email   !!!!! Change me !!!!!!!
EMAIL=your-name@your-domain.com
SMTP_HOST=&quot;localhost&quot;

# Full &quot;default&quot; path where to find sqlite (no quotes!)
SQLITE3_DIR=${HOME}/depkgs/sqlite3
SQLITE_DIR=${HOME}/depkgs/sqlite

TAPE_DRIVE=&quot;/dev/nst0&quot;
# if you don&#39;t have an autochanger set AUTOCHANGER to /dev/null
AUTOCHANGER=&quot;/dev/sg0&quot;
# For two drive tests -- set to /dev/null if you do not have it
TAPE_DRIVE1=&quot;/dev/null&quot;

# This must be the path to the autochanger including its name
AUTOCHANGER_PATH=&quot;/usr/sbin/mtx&quot;

# Set what backend to use &quot;postresql&quot; &quot;mysql&quot; or &quot;sqlite3&quot;
DBTYPE=&quot;postgresql&quot;

# Set your database here
#WHICHDB=&quot;--with-${DBTYPE}=${SQLITE3_DIR}&quot;
WHICHDB=&quot;--with-${DBTYPE}&quot;

# Set this to &quot;--with-tcp-wrappers&quot; or &quot;--without-tcp-wrappers&quot;
TCPWRAPPERS=&quot;--with-tcp-wrappers&quot;

# Set this to &quot;&quot; to disable OpenSSL support, &quot;--with-openssl=yes&quot;
# to enable it, or provide the path to the OpenSSL installation,
# eg &quot;--with-openssl=/usr/local&quot;
OPENSSL=&quot;--with-openssl&quot;

# You may put your real host name here, but localhost or 127.0.0.1
# is valid also and it has the advantage that it works on a
# non-networked machine
HOST=&quot;localhost&quot;</code></pre>
<ul>
<li><p><span><strong>BACULA_SOURCE</strong></span> should be the full path to the Bacula source code that you wish to test. It will be loaded configured, compiled, and installed with the “make setup” command, which needs to be done only once each time you change the source code.</p></li>
<li><p><span><strong>EMAIL</strong></span> should be your email addres. Please remember to change this or I will get a flood of unwanted messages. You may or may not want to see these emails. In my case, I don’t need them so I direct it to the bit bucket.</p></li>
<li><p><span><strong>SMTP_HOST</strong></span> defines where your SMTP server is.</p></li>
<li><p><span><strong>SQLITE_DIR</strong></span> should be the full path to the sqlite package, must be build before running a Bacula regression, if you are using SQLite. This variable is ignored if you are using MySQL or PostgreSQL. To use PostgreSQL, edit the Makefile and change (or add) WHICHDB?=“<code>--</code>with-postgresql”. For MySQL use “WHICHDB=”<code>--</code>with-mysql``.</p>
<p>The advantage of using SQLite is that it is totally independent of any installation you may have running on your system, and there is no special configuration or authorization that must be done to run it. With both MySQL and PostgreSQL, you must pre-install the packages, initialize them and ensure that you have authorization to access the database and create and delete tables.</p></li>
<li><p><span><strong>TAPE_DRIVE</strong></span> is the full path to your tape drive. The base set of regression tests do not use a tape, so this is only important if you want to run the full tests. Set this to /dev/null if you do not have a tape drive.</p></li>
<li><p><span><strong>TAPE_DRIVE1</strong></span> is the full path to your second tape drive, if have one. The base set of regression tests do not use a tape, so this is only important if you want to run the full two drive tests. Set this to /dev/null if you do not have a second tape drive.</p></li>
<li><p><span><strong>AUTOCHANGER</strong></span> is the name of your autochanger control device. Set this to /dev/null if you do not have an autochanger.</p></li>
<li><p><span><strong>AUTOCHANGER_PATH</strong></span> is the full path including the program name for your autochanger program (normally <span><strong>mtx</strong></span>. Leave the default value if you do not have one.</p></li>
<li><p><span><strong>TCPWRAPPERS</strong></span> defines whether or not you want the ./configure to be performed with tcpwrappers enabled.</p></li>
<li><p><span><strong>OPENSSL</strong></span> used to enable/disable SSL support for Bacula communications and data encryption.</p></li>
<li><p><span><strong>HOST</strong></span> is the hostname that it will use when building the scripts. The Bacula daemons will be named &lt;HOST&gt;-dir, &lt;HOST&gt;-fd, … It is also the name of the HOST machine that to connect to the daemons by the network. Hence the name should either be your real hostname (with an appropriate DNS or /etc/hosts entry) or <span><strong>localhost</strong></span> as it is in the default file.</p></li>
<li><p><span><strong>bin</strong></span> is the binary location.</p></li>
<li><p><span><strong>scripts</strong></span> is the bacula scripts location (where we could find database creation script, autochanger handler, etc.)</p></li>
</ul>
<h3 id="building-the-test-bacula">Building the Test Bacula</h3>
<p>Once the above variables are set, you can build the setup by entering:</p>
<pre><code>make setup</code></pre>
<p>This will setup the regression testing and you should not need to do this again unless you want to change the database or other regression configuration parameters.</p>
<h3 id="setting-up-your-sql-engine">Setting up your SQL engine</h3>
<p>If you are using SQLite or SQLite3, there is nothing more to do; you can simply run the tests as described in the next section.</p>
<p>If you are using MySQL or PostgreSQL, you will need to establish an account with your database engine for the user name <span><strong>regress</strong></span> and you will need to manually create a database named <span><strong>regress</strong></span> that can be used by user name regress, which means you will have to give the user regress sufficient permissions to use the database named regress. There is no password on the regress account.</p>
<p>You have probably already done this procedure for the user name and database named bacula. If not, the manual describes roughly how to do it, and the scripts in bacula/regress/build/src/cats named create_mysql_database, create_postgresql_database, grant_mysql_privileges, and grant_postgresql_privileges may be of a help to you.</p>
<p>Generally, to do the above, you will need to run under root to be able to create databases and modify permissions within MySQL and PostgreSQL.</p>
<p>It is possible to configure MySQL access for database accounts that require a password to be supplied. This can be done by creating a  /.my.cnf file which supplies the credentials by default to the MySQL commandline utilities.</p>
<pre><code>[client]
host     = localhost
user     = regress
password = asecret</code></pre>
<p>A similar technique can be used PostgreSQL regression testing where the database is configured to require a password. The  /.pgpass file should contain a line with the database connection properties.</p>
<pre><code>hostname:port:database:username:password</code></pre>
<h3 id="running-the-disk-only-regression">Running the Disk Only Regression</h3>
<p>The simplest way to copy the source code, configure it, compile it, link it, and run the tests is to use a helper script:</p>
<pre><code>./do_disk</code></pre>
<p>This will run the base set of tests using disk Volumes. If you are testing on a non-Linux machine several of the of the tests may not be run. In any case, as we add new tests, the number will vary. It will take about 1 hour and you don’t need to be root to run these tests (I run under my regular userid). The result should be something similar to:</p>
<pre><code>Test results
  ===== auto-label-test OK 12:31:33 =====
  ===== backup-bacula-test OK 12:32:32 =====
  ===== bextract-test OK 12:33:27 =====
  ===== bscan-test OK 12:34:47 =====
  ===== bsr-opt-test OK 12:35:46 =====
  ===== compressed-test OK 12:36:52 =====
  ===== compressed-encrypt-test OK 12:38:18 =====
  ===== concurrent-jobs-test OK 12:39:49 =====
  ===== data-encrypt-test OK 12:41:11 =====
  ===== encrypt-bug-test OK 12:42:00 =====
  ===== fifo-test OK 12:43:46 =====
  ===== backup-bacula-fifo OK 12:44:54 =====
  ===== differential-test OK 12:45:36 =====
  ===== four-concurrent-jobs-test OK 12:47:39 =====
  ===== four-jobs-test OK 12:49:22 =====
  ===== incremental-test OK 12:50:38 =====
  ===== query-test OK 12:51:37 =====
  ===== recycle-test OK 12:53:52 =====
  ===== restore2-by-file-test OK 12:54:53 =====
  ===== restore-by-file-test OK 12:55:40 =====
  ===== restore-disk-seek-test OK 12:56:29 =====
  ===== six-vol-test OK 12:57:44 =====
  ===== span-vol-test OK 12:58:52 =====
  ===== sparse-compressed-test OK 13:00:00 =====
  ===== sparse-test OK 13:01:04 =====
  ===== two-jobs-test OK 13:02:39 =====
  ===== two-vol-test OK 13:03:49 =====
  ===== verify-vol-test OK 13:04:56 =====
  ===== weird-files2-test OK 13:05:47 =====
  ===== weird-files-test OK 13:06:33 =====
  ===== migration-job-test OK 13:08:15 =====
  ===== migration-jobspan-test OK 13:09:33 =====
  ===== migration-volume-test OK 13:10:48 =====
  ===== migration-time-test OK 13:12:59 =====
  ===== hardlink-test OK 13:13:50 =====
  ===== two-pool-test OK 13:18:17 =====
  ===== fast-two-pool-test OK 13:24:02 =====
  ===== two-volume-test OK 13:25:06 =====
  ===== incremental-2disk OK 13:25:57 =====
  ===== 2drive-incremental-2disk OK 13:26:53 =====
  ===== scratch-pool-test OK 13:28:01 =====
Total time = 0:57:55 or 3475 secs</code></pre>
<p>and the working tape tests are run with</p>
<pre><code>make full_test

Test results

  ===== Bacula tape test OK =====
  ===== Small File Size test OK =====
  ===== restore-by-file-tape test OK =====
  ===== incremental-tape test OK =====
  ===== four-concurrent-jobs-tape OK =====
  ===== four-jobs-tape OK =====</code></pre>
<p>Each separate test is self contained in that it initializes to run Bacula from scratch (i.e. newly created database). It will also kill any Bacula session that is currently running. In addition, it uses ports 8101, 8102, and 8103 so that it does not intefere with a production system.</p>
<p>Alternatively, you can do the ./do_disk work by hand with:</p>
<pre><code>make setup</code></pre>
<p>The above will then copy the source code within the regression tree (in directory regress/build), configure it, and build it. There should be no errors. If there are, please correct them before continuing. From this point on, as long as you don’t change the Bacula source code, you should not need to repeat any of the above steps. If you pull down a new version of the source code, simply run <span><strong>make setup</strong></span> again.</p>
<p>Once Bacula is built, you can run the basic disk only non-root regression test by entering:</p>
<pre><code>make test</code></pre>
<h3 id="other-tests">Other Tests</h3>
<p>There are a number of other tests that can be run as well. All the tests are a simply shell script keep in the regress directory. For example the ”make test`` simply executes <span><strong>./all-non-root-tests</strong></span>. The other tests, which are invoked by directly running the script are:</p>
<dl>
<dt>all_non-root-tests</dt>
<dd><p>All non-tape tests not requiring root. This is the standard set of tests, that in general, backup some data, then restore it, and finally compares the restored data with the original data.</p>
</dd>
<dt>all-root-tests</dt>
<dd><p>All non-tape tests requiring root permission. These are a relatively small number of tests that require running as root. The amount of data backed up can be quite large. For example, one test backs up /usr, another backs up /etc. One or more of these tests reports an error – I’ll fix it one day.</p>
</dd>
<dt>all-non-root-tape-tests</dt>
<dd><p>All tape test not requiring root. There are currently three tests, all run without being root, and backup to a tape. The first two tests use one volume, and the third test requires an autochanger, and uses two volumes. If you don’t have an autochanger, then this script will probably produce an error.</p>
</dd>
<dt>all-tape-and-file-tests</dt>
<dd><p>All tape and file tests not requiring root. This includes just about everything, and I don’t run it very often.</p>
</dd>
</dl>
<h3 id="if-a-test-fails">If a Test Fails</h3>
<p>If you one or more tests fail, the line output will be similar to:</p>
<pre><code>  !!!!! concurrent-jobs-test failed!!! !!!!!</code></pre>
<p>If you want to determine why the test failed, you will need to rerun the script with the debug output turned on. You do so by defining the environment variable <span><strong>REGRESS_DEBUG</strong></span> with commands such as:</p>
<pre><code>REGRESS_DEBUG=1
export REGRESS_DEBUG</code></pre>
<p>Then from the “regress” directory (all regression scripts assume that you have “regress” as the current directory), enter:</p>
<pre><code>tests/test-name</code></pre>
<p>where test-name should be the name of a test script – for example: <span><strong>tests/backup-bacula-test</strong></span>.</p>
<h2 id="testing-a-binary-installation">Testing a Binary Installation</h2>
<p>If you have installed your Bacula from a binary release such as (rpms or debs), you can still run regression tests on it. First, make sure that your regression <span><strong>config</strong></span> file uses the same catalog backend as your installed binaries. Then define the variables <code>bin</code> and <code>scripts</code> variables in your config file.</p>
<p>Example:</p>
<pre><code>bin=/opt/bacula/bin
scripts=/opt/bacula/scripts</code></pre>
<p>The <code>./scripts/prepare-other-loc</code> will tweak the regress scripts to use your binary location. You will need to run it manually once before you run any regression tests.</p>
<pre><code>$ ./scripts/prepare-other-loc
$ ./tests/backup-bacula-test
...</code></pre>
<p>All regression scripts must be run by hand or by calling the test scripts. These are principally scripts that begin with <span><strong>all_…</strong></span> such as <span><strong>all_disk_tests</strong></span>, <span><strong>./all_test</strong></span> … None of the <span><strong>./do_disk</strong></span>, <span><strong>./do_all</strong></span>, <span><strong>./nightly…</strong></span> scripts will work.</p>
<p>If you want to switch back to running the regression scripts from source, first remove the <span><strong>bin</strong></span> and <span><strong>scripts</strong></span> variables from your <span><strong>config</strong></span> file and rerun the <span><strong>make setup</strong></span> step.</p>
<h2 id="running-a-single-test">Running a Single Test</h2>
<p>If you wish to run a single test, you can simply:</p>
<pre><code>cd regress
tests/&lt;name-of-test&gt;</code></pre>
<p>or, if the source code has been updated, you would do:</p>
<pre><code>cd bacula
git pull
cd regress
make setup
tests/backup-to-null</code></pre>
<h2 id="writing-a-regression-test">Writing a Regression Test</h2>
<p>Any developer, who implements a major new feature, should write a regression test that exercises and validates the new feature. Each regression test is a complete test by itself. It terminates any running Bacula, initializes the database, starts Bacula, then runs the test by using the console program.</p>
<h3 id="running-the-tests-by-hand">Running the Tests by Hand</h3>
<p>You can run any individual test by hand by cd’ing to the <span><strong>regress</strong></span> directory and entering:</p>
<pre><code>tests/&lt;test-name&gt;</code></pre>
<h3 id="directory-structure">Directory Structure</h3>
<p>The directory structure of the regression tests is:</p>
<pre><code>  regress                - Makefile, scripts to start tests
    |------ scripts      - Scripts and conf files
    |-------tests        - All test scripts are here
    |
    |------------------ -- All directories below this point are used
    |                       for testing, but are created from the
    |                       above directories and are removed with
    |                       &quot;make distclean&quot;
    |
    |------ bin          - This is the install directory for
    |                        Bacula to be used testing
    |------ build        - Where the Bacula source build tree is
    |------ tmp          - Most temp files go here
    |------ working      - Bacula working directory
    |------ weird-files  - Weird files used in two of the tests.</code></pre>
<h3 id="adding-a-new-test">Adding a New Test</h3>
<p>If you want to write a new regression test, it is best to start with one of the existing test scripts, and modify it to do the new test.</p>
<p>When adding a new test, be extremely careful about adding anything to any of the daemons’ configuration files. The reason is that it may change the prompts that are sent to the console. For example, adding a Pool means that the current scripts, which assume that Bacula automatically selects a Pool, will now be presented with a new prompt, so the test will fail. If you need to enhance the configuration files, consider making your own versions.</p>
<h3 id="running-a-test-under-the-debugger">Running a Test Under The Debugger</h3>
<p>You can run a test under the debugger (actually run a Bacula daemon under the debugger) by first setting the environment variable <span><strong>REGRESS_WAIT</strong></span> with commands such as:</p>
<pre><code>REGRESS_WAIT=1
export REGRESS_WAIT</code></pre>
<p>Then executing the script. When the script prints the following line:</p>
<pre><code>Start Bacula under debugger and enter anything when ready ...</code></pre>
<p>You start the Bacula component you want to run under the debugger in a different shell window. For example:</p>
<pre><code>cd .../regress/bin
gdb bacula-sd
(possibly set breakpoints, ...)
run -s -f</code></pre>
<p>Then enter any character in the window with the above message. An error message will appear saying that the daemon you are debugging is already running, which is the case. You can simply ignore the error message.</p>
<h1 id="MD5Chapter">Bacula MD5 Algorithm</h1>
<h2 id="command-line-message-digest-utility">Command Line Message Digest Utility</h2>
<p>This page describes <span><strong>md5</strong></span>, a command line utility usable on either Unix or MS-DOS/Windows, which generates and verifies message digests (digital signatures) using the MD5 algorithm. This program can be useful when developing shell scripts or Perl programs for software installation, file comparison, and detection of file corruption and tampering.</p>
<h3 id="name">Name</h3>
<p><span><strong>md5</strong></span> - generate / check MD5 message digest</p>
<h3 id="synopsis">Synopsis</h3>
<p><span><strong>md5</strong></span> [ <span><strong>-c</strong></span><span><em>signature</em></span> ] [ <span><strong>-u</strong></span> ] [ <span><strong>-d</strong></span><span><em>input_text</em></span> | <span><em>infile</em></span> ] [ <span><em>outfile</em></span> ]</p>
<h3 id="description">Description</h3>
<p>A <span><em>message digest</em></span> is a compact digital signature for an arbitrarily long stream of binary data. An ideal message digest algorithm would never generate the same signature for two different sets of input, but achieving such theoretical perfection would require a message digest as long as the input file. Practical message digest algorithms compromise in favour of a digital signature of modest size created with an algorithm designed to make preparation of input text with a given signature computationally infeasible. Message digest algorithms have much in common with techniques used in encryption, but to a different end; verification that data have not been altered since the signature was published.</p>
<p>Many older programs requiring digital signatures employed 16 or 32 bit <span><em>cyclical redundancy codes</em></span> (CRC) originally developed to verify correct transmission in data communication protocols, but these short codes, while adequate to detect the kind of transmission errors for which they were intended, are insufficiently secure for applications such as electronic commerce and verification of security related software distributions.</p>
<p>The most commonly used present-day message digest algorithm is the 128 bit MD5 algorithm, developed by Ron Rivest of the and The algorithm, with a reference implementation, was published as Internet in April 1992, and was placed into the public domain at that time. Message digest algorithms such as MD5 are not deemed “encryption technology” and are not subject to the export controls some governments impose on other data security products. (Obviously, the responsibility for obeying the laws in the jurisdiction in which you reside is entirely your own, but many common Web and Mail utilities use MD5, and I am unaware of any restrictions on their distribution and use.)</p>
<p>The MD5 algorithm has been implemented in numerous computer languages including C, , and ; if you’re writing a program in such a language, track down a suitable subroutine and incorporate it into your program. The program described on this page is a <span><em>command line</em></span> implementation of MD5, intended for use in shell scripts and Perl programs (it is much faster than computing an MD5 signature directly in Perl). This <span><strong>md5</strong></span> program was originally developed as part of a suite of tools intended to monitor large collections of files (for example, the contents of a Web site) to detect corruption of files and inadvertent (or perhaps malicious) changes. That task is now best accomplished with more comprehensive packages such as , but the command line <span><strong>md5</strong></span> component continues to prove useful for verifying correct delivery and installation of software packages, comparing the contents of two different systems, and checking for changes in specific files.</p>
<h3 id="options">Options</h3>
<dl>
<dt><span><strong>-c</strong></span><span><em>signature</em></span></dt>
<dd><p>Computes the signature of the specified <span><em>infile</em></span> or the string supplied by the <span><strong>-d</strong></span> option and compares it against the specified <span><em>signature</em></span>. If the two signatures match, the exit status will be zero, otherwise the exit status will be 1. No signature is written to <span><em>outfile</em></span> or standard output; only the exit status is set. The signature to be checked must be specified as 32 hexadecimal digits.</p>
</dd>
<dt><span><strong>-d</strong></span><span><em>input_text</em></span></dt>
<dd><p>A signature is computed for the given <span><em>input_text</em></span> (which must be quoted if it contains white space characters) instead of input from <span><em>infile</em></span> or standard input. If input is specified with the <span><strong>-d</strong></span> option, no <span><em>infile</em></span> should be specified.</p>
</dd>
<dt><span><strong>-u</strong></span></dt>
<dd><p>Print how-to-call information.</p>
</dd>
</dl>
<h3 id="files">Files</h3>
<p>If no <span><em>infile</em></span> or <span><strong>-d</strong></span> option is specified or <span><em>infile</em></span> is a single “-”, <span><strong>md5</strong></span> reads from standard input; if no <span><em>outfile</em></span> is given, or <span><em>outfile</em></span> is a single “-”, output is sent to standard output. Input and output are processed strictly serially; consequently <span><strong>md5</strong></span> may be used in pipelines.</p>
<h3 id="bugs">Bugs</h3>
<p>The mechanism used to set standard input to binary mode may be specific to Microsoft C; if you rebuild the DOS/Windows version of the program from source using another compiler, be sure to verify binary files work properly when read via redirection or a pipe.</p>
<p>This program has not been tested on a machine on which <span>int</span> and/or <span>long</span> are longer than 32 bits.</p>
<h2 id="zipped-archive">(Zipped archive)</h2>
<p>The program is provided as , a archive containing an ready-to-run Win32 command-line executable program, <span>md5.exe</span> (compiled using Microsoft Visual C++ 5.0), and in source code form along with a <span>Makefile</span> to build the program under Unix.</p>
<h3 id="see-also">See Also</h3>
<p><span><strong>sum</strong></span>(1)</p>
<h3 id="exit-status">Exit Status</h3>
<p><span><strong>md5</strong></span> returns status 0 if processing was completed without errors, 1 if the <span><strong>-c</strong></span> option was specified and the given signature does not match that of the input, and 2 if processing could not be performed at all due, for example, to a nonexistent input file.</p>
<h3 id="copying">Copying</h3>
<blockquote>
<p>This software is in the public domain. Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, without any conditions or restrictions. This software is provided “as is” without express or implied warranty.</p>
</blockquote>
<h3 id="acknowledgements">Acknowledgements</h3>
<p>The MD5 algorithm was developed by Ron Rivest. The public domain C language implementation used in this program was written by Colin Plumb in 1993. <span>* January 6th, MIM *</span></p>
<p>Bacula Memory Management {#_ChapterStart7} ========================</p>
<h2 id="general-5">General</h2>
<p>This document describes the memory management routines that are used in Bacula and is meant to be a technical discussion for developers rather than part of the user manual.</p>
<p>Since Bacula may be called upon to handle filenames of varying and more or less arbitrary length, special attention needs to be used in the code to ensure that memory buffers are sufficiently large. There are four possibilities for memory usage within <span><strong>Bacula</strong></span>. Each will be described in turn. They are:</p>
<ul>
<li><p>Statically allocated memory.</p></li>
<li><p>Dynamically allocated memory using malloc() and free().</p></li>
<li><p>Non-pooled memory.</p></li>
<li><p>Pooled memory.</p></li>
</ul>
<h3 id="statically-allocated-memory">Statically Allocated Memory</h3>
<p>Statically allocated memory is of the form:</p>
<pre><code>char buffer[MAXSTRING];</code></pre>
<p>The use of this kind of memory is discouraged except when you are 100% sure that the strings to be used will be of a fixed length. One example of where this is appropriate is for <span><strong>Bacula</strong></span> resource names, which are currently limited to 127 characters (MAX_NAME_LENGTH). Although this maximum size may change, particularly to accommodate Unicode, it will remain a relatively small value.</p>
<h3 id="dynamically-allocated-memory">Dynamically Allocated Memory</h3>
<p>Dynamically allocated memory is obtained using the standard malloc() routines. As in:</p>
<pre><code>char *buf;
buf = malloc(256);</code></pre>
<p>This kind of memory can be released with:</p>
<pre><code>free(buf);</code></pre>
<p>It is recommended to use this kind of memory only when you are sure that you know the memory size needed and the memory will be used for short periods of time – that is it would not be appropriate to use statically allocated memory. An example might be to obtain a large memory buffer for reading and writing files. When <span><strong>SmartAlloc</strong></span> is enabled, the memory obtained by malloc() will automatically be checked for buffer overwrite (overflow) during the free() call, and all malloc’ed memory that is not released prior to termination of the program will be reported as Orphaned memory.</p>
<h3 id="pooled-and-non-pooled-memory">Pooled and Non-pooled Memory</h3>
<p>In order to facility the handling of arbitrary length filenames and to efficiently handle a high volume of dynamic memory usage, we have implemented routines between the C code and the malloc routines. The first is called “Pooled” memory, and is memory, which once allocated and then released, is not returned to the system memory pool, but rather retained in a Bacula memory pool. The next request to acquire pooled memory will return any free memory block. In addition, each memory block has its current size associated with the block allowing for easy checking if the buffer is of sufficient size. This kind of memory would normally be used in high volume situations (lots of malloc()s and free()s) where the buffer length may have to frequently change to adapt to varying filename lengths.</p>
<p>The non-pooled memory is handled by routines similar to those used for pooled memory, allowing for easy size checking. However, non-pooled memory is returned to the system rather than being saved in the Bacula pool. This kind of memory would normally be used in low volume situations (few malloc()s and free()s), but where the size of the buffer might have to be adjusted frequently.</p>
<h5 id="types-of-memory-pool" class="unnumbered">Types of Memory Pool:</h5>
<p>Currently there are three memory pool types:</p>
<ul>
<li><p>PM_NOPOOL – non-pooled memory.</p></li>
<li><p>PM_FNAME – a filename pool.</p></li>
<li><p>PM_MESSAGE – a message buffer pool.</p></li>
<li><p>PM_EMSG – error message buffer pool.</p></li>
</ul>
<h5 id="getting-memory" class="unnumbered">Getting Memory:</h5>
<p>To get memory, one uses:</p>
<pre><code>void *get_pool_memory(pool);</code></pre>
<p>where <span><strong>pool</strong></span> is one of the above mentioned pool names. The size of the memory returned will be determined by the system to be most appropriate for the application.</p>
<p>If you wish non-pooled memory, you may alternatively call:</p>
<pre><code>void *get_memory(size_t size);</code></pre>
<p>The buffer length will be set to the size specified, and it will be assigned to the PM_NOPOOL pool (no pooling).</p>
<h5 id="releasing-memory" class="unnumbered">Releasing Memory:</h5>
<p>To free memory acquired by either of the above two calls, use:</p>
<pre><code>void free_pool_memory(void *buffer);</code></pre>
<p>where buffer is the memory buffer returned when the memory was acquired. If the memory was originally allocated as type PM_NOPOOL, it will be released to the system, otherwise, it will be placed on the appropriate Bacula memory pool free chain to be used in a subsequent call for memory from that pool.</p>
<h5 id="determining-the-memory-size" class="unnumbered">Determining the Memory Size:</h5>
<p>To determine the memory buffer size, use:</p>
<pre><code>size_t sizeof_pool_memory(void *buffer);</code></pre>
<h5 id="resizing-pool-memory" class="unnumbered">Resizing Pool Memory:</h5>
<p>To resize pool memory, use:</p>
<pre><code>void *realloc_pool_memory(void *buffer);</code></pre>
<p>The buffer will be reallocated, and the contents of the original buffer will be preserved, but the address of the buffer may change.</p>
<h5 id="automatic-size-adjustment" class="unnumbered">Automatic Size Adjustment:</h5>
<p>To have the system check and if necessary adjust the size of your pooled memory buffer, use:</p>
<pre><code>void *check_pool_memory_size(void *buffer, size_t new-size);</code></pre>
<p>where <span><strong>new-size</strong></span> is the buffer length needed. Note, if the buffer is already equal to or larger than <span><strong>new-size</strong></span> no buffer size change will occur. However, if a buffer size change is needed, the original contents of the buffer will be preserved, but the buffer address may change. Many of the low level Bacula subroutines expect to be passed a pool memory buffer and use this call to ensure the buffer they use is sufficiently large.</p>
<h5 id="releasing-all-pooled-memory" class="unnumbered">Releasing All Pooled Memory:</h5>
<p>In order to avoid orphaned buffer error messages when terminating the program, use:</p>
<pre><code>void close_memory_pool();</code></pre>
<p>to free all unused memory retained in the Bacula memory pool. Note, any memory not returned to the pool via free_pool_memory() will not be released by this call.</p>
<h5 id="pooled-memory-statistics" class="unnumbered">Pooled Memory Statistics:</h5>
<p>For debugging purposes and performance tuning, the following call will print the current memory pool statistics:</p>
<pre><code>void print_memory_pool_stats();</code></pre>
<p>an example output is:</p>
<pre><code>Pool  Maxsize  Maxused  Inuse
   0      256        0      0
   1      256        1      0
   2      256        1      0</code></pre>
<p>TCP/IP Network Protocol {#_ChapterStart5} =======================</p>
<h2 id="general-6">General</h2>
<p>This document describes the TCP/IP protocol used by Bacula to communicate between the various daemons and services. The definitive definition of the protocol can be found in src/lib/bsock.h, src/lib/bnet.c and src/lib/bnet_server.c.</p>
<p>Bacula’s network protocol is basically a “packet oriented” protocol built on a standard TCP/IP streams. At the lowest level all packet transfers are done with read() and write() requests on system sockets. Pipes are not used as they are considered unreliable for large serial data transfers between various hosts.</p>
<p>Using the routines described below (bnet_open, bnet_write, bnet_recv, and bnet_close) guarantees that the number of bytes you write into the socket will be received as a single record on the other end regardless of how many low level write() and read() calls are needed. All data transferred are considered to be binary data.</p>
<h2 id="bnet-and-threads">bnet and Threads</h2>
<p>These bnet routines work fine in a threaded environment. However, they assume that there is only one reader or writer on the socket at any time. It is highly recommended that only a single thread access any BSOCK packet. The exception to this rule is when the socket is first opened and it is waiting for a job to start. The wait in the Storage daemon is done in one thread and then passed to another thread for subsequent handling.</p>
<p>If you envision having two threads using the same BSOCK, think twice, then you must implement some locking mechanism. However, it probably would not be appropriate to put locks inside the bnet subroutines for efficiency reasons.</p>
<h2 id="bnet_open">bnet_open</h2>
<p>To establish a connection to a server, use the subroutine:</p>
<p>BSOCK *bnet_open(void *jcr, char *host, char *service, int port, int *fatal) bnet_open(), if successful, returns the Bacula sock descriptor pointer to be used in subsequent bnet_send() and bnet_read() requests. If not successful, bnet_open() returns a NULL. If fatal is set on return, it means that a fatal error occurred and that you should not repeatedly call bnet_open(). Any error message will generally be sent to the JCR.</p>
<h2 id="bnet_send">bnet_send</h2>
<p>To send a packet, one uses the subroutine:</p>
<p>int bnet_send(BSOCK *sock) This routine is equivalent to a write() except that it handles the low level details. The data to be sent is expected to be in sock-<span>&gt;</span>msg and be sock-<span>&gt;</span>msglen bytes. To send a packet, bnet_send() first writes four bytes in network byte order than indicate the size of the following data packet. It returns:</p>
<pre><code> Returns 0 on failure
 Returns 1 on success</code></pre>
<p>In the case of a failure, an error message will be sent to the JCR contained within the bsock packet.</p>
<h2 id="bnet_fsend">bnet_fsend</h2>
<p>This form uses:</p>
<p>int bnet_fsend(BSOCK *sock, char *format, …) and it allows you to send a formatted messages somewhat like fprintf(). The return status is the same as bnet_send.</p>
<h2 id="additional-error-information">Additional Error information</h2>
<p>Fro additional error information, you can call <span><strong>is_bnet_error(BSOCK *bsock)</strong></span> which will return 0 if there is no error or non-zero if there is an error on the last transmission. The <span><strong>is_bnet_stop(BSOCK *bsock)</strong></span> function will return 0 if there no errors and you can continue sending. It will return non-zero if there are errors or the line is closed (no more transmissions should be sent).</p>
<h2 id="bnet_recv">bnet_recv</h2>
<p>To read a packet, one uses the subroutine:</p>
<p>int bnet_recv(BSOCK *sock) This routine is similar to a read() except that it handles the low level details. bnet_read() first reads packet length that follows as four bytes in network byte order. The data is read into sock-<span>&gt;</span>msg and is sock-<span>&gt;</span>msglen bytes. If the sock-<span>&gt;</span>msg is not large enough, bnet_recv() realloc() the buffer. It will return an error (-2) if maxbytes is less than the record size sent. It returns:</p>
<pre><code> * Returns number of bytes read
 * Returns 0 on end of file
 * Returns -1 on hard end of file (i.e. network connection close)
 * Returns -2 on error</code></pre>
<p>It should be noted that bnet_recv() is a blocking read.</p>
<h2 id="bnet_sig">bnet_sig</h2>
<p>To send a “signal” from one daemon to another, one uses the subroutine:</p>
<p>int bnet_sig(BSOCK *sock, SIGNAL) where SIGNAL is one of the following:</p>
<ol style="list-style-type: decimal">
<li><p>BNET_EOF - deprecated use BNET_EOD</p></li>
<li><p>BNET_EOD - End of data stream, new data may follow</p></li>
<li><p>BNET_EOD_POLL - End of data and poll all in one</p></li>
<li><p>BNET_STATUS - Request full status</p></li>
<li><p>BNET_TERMINATE - Conversation terminated, doing close()</p></li>
<li><p>BNET_POLL - Poll request, I’m hanging on a read</p></li>
<li><p>BNET_HEARTBEAT - Heartbeat Response requested</p></li>
<li><p>BNET_HB_RESPONSE - Only response permitted to HB</p></li>
<li><p>BNET_PROMPT - Prompt for UA</p></li>
</ol>
<h2 id="bnet_strerror">bnet_strerror</h2>
<p>Returns a formated string corresponding to the last error that occurred.</p>
<h2 id="bnet_close">bnet_close</h2>
<p>The connection with the server remains open until closed by the subroutine:</p>
<p>void bnet_close(BSOCK *sock)</p>
<h2 id="becoming-a-server">Becoming a Server</h2>
<p>The bnet_open() and bnet_close() routines described above are used on the client side to establish a connection and terminate a connection with the server. To become a server (i.e. wait for a connection from a client), use the routine <span><strong>bnet_thread_server</strong></span>. The calling sequence is a bit complicated, please refer to the code in bnet_server.c and the code at the beginning of each daemon as examples of how to call it.</p>
<h2 id="higher-level-conventions">Higher Level Conventions</h2>
<p>Within Bacula, we have established the convention that any time a single record is passed, it is sent with bnet_send() and read with bnet_recv(). Thus the normal exchange between the server (S) and the client (C) are:</p>
<pre><code>S: wait for connection            C: attempt connection
S: accept connection              C: bnet_send() send request
S: bnet_recv() wait for request
S: act on request
S: bnet_send() send ack            C: bnet_recv() wait for ack</code></pre>
<p>Thus a single command is sent, acted upon by the server, and then acknowledged.</p>
<p>In certain cases, such as the transfer of the data for a file, all the information or data cannot be sent in a single packet. In this case, the convention is that the client will send a command to the server, who knows that more than one packet will be returned. In this case, the server will enter a loop:</p>
<pre><code>while ((n=bnet_recv(bsock)) &gt; 0) {
   act on request
}
if (n &lt; 0)
   error</code></pre>
<p>The client will perform the following:</p>
<pre><code>bnet_send(bsock);
bnet_send(bsock);
...
bnet_sig(bsock, BNET_EOD);</code></pre>
<p>Thus the client will send multiple packets and signal to the server when all the packets have been sent by sending a zero length record.</p>
<div class="figure">
<embed src="\idir%20smartall.eps" /><p class="caption">image</p>
</div>
<p>Smart Memory Allocation {#_ChapterStart4} =======================</p>
<p>Few things are as embarrassing as a program that leaks, yet few errors are so easy to commit or as difficult to track down in a large, complicated program as failure to release allocated memory. SMARTALLOC replaces the standard C library memory allocation functions with versions which keep track of buffer allocations and releases and report all orphaned buffers at the end of program execution. By including this package in your program during development and testing, you can identify code that loses buffers right when it’s added and most easily fixed, rather than as part of a crisis debugging push when the problem is identified much later in the testing cycle (or even worse, when the code is in the hands of a customer). When program testing is complete, simply recompiling with different flags removes SMARTALLOC from your program, permitting it to run without speed or storage penalties.</p>
<p>In addition to detecting orphaned buffers, SMARTALLOC also helps to find other common problems in management of dynamic storage including storing before the start or beyond the end of an allocated buffer, referencing data through a pointer to a previously released buffer, attempting to release a buffer twice or releasing storage not obtained from the allocator, and assuming the initial contents of storage allocated by functions that do not guarantee a known value. SMARTALLOC’s checking does not usually add a large amount of overhead to a program (except for programs which use <span>realloc()</span> extensively; see below). SMARTALLOC focuses on proper storage management rather than internal consistency of the heap as checked by the malloc_debug facility available on some systems. SMARTALLOC does not conflict with malloc_debug and both may be used together, if you wish. SMARTALLOC makes no assumptions regarding the internal structure of the heap and thus should be compatible with any C language implementation of the standard memory allocation functions.</p>
<h3 id="installing-smartalloc">Installing SMARTALLOC</h3>
<p>SMARTALLOC is provided as a Zipped archive, ; see the download instructions below.</p>
<p>To install SMARTALLOC in your program, simply add the statement:</p>
<p>to every C program file which calls any of the memory allocation functions (<span>malloc</span>, <span>calloc</span>, <span>free</span>, etc.). SMARTALLOC must be used for all memory allocation with a program, so include file for your entire program, if you have such a thing. Next, define the symbol SMARTALLOC in the compilation before the inclusion of smartall.h. I usually do this by having my Makefile add the “<span>-DSMARTALLOC</span>” option to the C compiler for non-production builds. You can define the symbol manually, if you prefer, by adding the statement:</p>
<p><span>#define SMARTALLOC</span></p>
<p>At the point where your program is all done and ready to relinquish control to the operating system, add the call:</p>
<p><span>        sm_dump(</span><span><em>datadump</em></span><span>);</span></p>
<p>where <span><em>datadump</em></span> specifies whether the contents of orphaned buffers are to be dumped in addition printing to their size and place of allocation. The data are dumped only if <span><em>datadump</em></span> is nonzero, so most programs will normally use “<span>sm_dump(0);</span>”. If a mysterious orphaned buffer appears that can’t be identified from the information this prints about it, replace the statement with “<span>sm_dump(1)</span>;”. Usually the dump of the buffer’s data will furnish the additional clues you need to excavate and extirpate the elusive error that left the buffer allocated.</p>
<p>Finally, add the files “smartall.h” and “smartall.c” from this release to your source directory, make dependencies, and linker input. You needn’t make inclusion of smartall.c in your link optional; if compiled with SMARTALLOC not defined it generates no code, so you may always include it knowing it will waste no storage in production builds. Now when you run your program, if it leaves any buffers around when it’s done, each will be reported by <span>sm_dump()</span> on stderr as follows:</p>
<pre><code>Orphaned buffer:     120 bytes allocated at line 50 of gutshot.c</code></pre>
<h3 id="squelching-a-smartalloc">Squelching a SMARTALLOC</h3>
<p>Usually, when you first install SMARTALLOC in an existing program you’ll find it nattering about lots of orphaned buffers. Some of these turn out to be legitimate errors, but some are storage allocated during program initialisation that, while dynamically allocated, is logically static storage not intended to be released. Of course, you can get rid of the complaints about these buffers by adding code to release them, but by doing so you’re adding unnecessary complexity and code size to your program just to silence the nattering of a SMARTALLOC, so an escape hatch is provided to eliminate the need to release these buffers.</p>
<p>Normally all storage allocated with the functions <span>malloc()</span>, <span>calloc()</span>, and <span>realloc()</span> is monitored by SMARTALLOC. If you make the function call:</p>
<pre><code>        sm_static(1);</code></pre>
<p>you declare that subsequent storage allocated by <span>malloc()</span>, <span>calloc()</span>, and <span>realloc()</span> should not be considered orphaned if found to be allocated when <span>sm_dump()</span> is called. I use a call on “<span>sm_static(1);</span>” before I allocate things like program configuration tables so I don’t have to add code to release them at end of program time. After allocating unmonitored data this way, be sure to add a call to:</p>
<pre><code>        sm_static(0);</code></pre>
<p>to resume normal monitoring of buffer allocations. Buffers allocated while <span>sm_static(1</span>) is in effect are not checked for having been orphaned but all the other safeguards provided by SMARTALLOC remain in effect. You may release such buffers, if you like; but you don’t have to.</p>
<h3 id="living-with-libraries">Living with Libraries</h3>
<p>Some library functions for which source code is unavailable may gratuitously allocate and return buffers that contain their results, or require you to pass them buffers which they subsequently release. If you have source code for the library, by far the best approach is to simply install SMARTALLOC in it, particularly since this kind of ill-structured dynamic storage management is the source of so many storage leaks. Without source code, however, there’s no option but to provide a way to bypass SMARTALLOC for the buffers the library allocates and/or releases with the standard system functions.</p>
<p>For each function <span><em>xxx</em></span> redefined by SMARTALLOC, a corresponding routine named “<span>actually</span><span><em>xxx</em></span>” is furnished which provides direct access to the underlying system function, as follows:</p>
<blockquote>
<p><span>ll</span> &amp;<br /><span><span>malloc(</span><span><em>size</em></span><span>)</span> </span> &amp; <span><span>actuallymalloc(</span><span><em>size</em></span><span>)</span> </span><br /><span><span>calloc(</span><span><em>nelem</em></span><span>,</span> <span><em>elsize</em></span><span>)</span> </span> &amp; <span><span>actuallycalloc(</span><span><em>nelem</em></span>, <span><em>elsize</em></span><span>)</span> </span><br /><span><span>realloc(</span><span><em>ptr</em></span><span>,</span> <span><em>size</em></span><span>)</span> </span> &amp; <span><span>actuallyrealloc(</span><span><em>ptr</em></span>, <span><em>size</em></span><span>)</span> </span><br /><span><span>free(</span><span><em>ptr</em></span><span>)</span> </span> &amp; <span><span>actuallyfree(</span><span><em>ptr</em></span><span>)</span> </span></p>
</blockquote>
<p>For example, suppose there exists a system library function named “<span>getimage()</span>” which reads a raster image file and returns the address of a buffer containing it. Since the library routine allocates the image directly with <span>malloc()</span>, you can’t use SMARTALLOC’s <span>free()</span>, as that call expects information placed in the buffer by SMARTALLOC’s special version of <span>malloc()</span>, and hence would report an error. To release the buffer you should call <span>actuallyfree()</span>, as in this code fragment:</p>
<pre><code>        struct image *ibuf = getimage(&quot;ratpack.img&quot;);
        display_on_screen(ibuf);
        actuallyfree(ibuf);</code></pre>
<p>Conversely, suppose we are to call a library function, “<span>putimage()</span>”, which writes an image buffer into a file and then releases the buffer with <span>free()</span>. Since the system <span>free()</span> is being called, we can’t pass a buffer allocated by SMARTALLOC’s allocation routines, as it contains special information that the system <span>free()</span> doesn’t expect to be there. The following code uses <span>actuallymalloc()</span> to obtain the buffer passed to such a routine.</p>
<pre><code>        struct image *obuf =
           (struct image *) actuallymalloc(sizeof(struct image));
        dump_screen_to_image(obuf);
        putimage(&quot;scrdump.img&quot;, obuf);  /* putimage() releases obuf */</code></pre>
<p>It’s unlikely you’ll need any of the “actually” calls except under very odd circumstances (in four products and three years, I’ve only needed them once), but they’re there for the rare occasions that demand them. Don’t use them to subvert the error checking of SMARTALLOC; if you want to disable orphaned buffer detection, use the <span>sm_static(1)</span> mechanism described above. That way you don’t forfeit all the other advantages of SMARTALLOC as you do when using <span>actuallymalloc()</span> and <span>actuallyfree()</span>.</p>
<h3 id="smartalloc-details">SMARTALLOC Details</h3>
<p>When you include “smartall.h” and define SMARTALLOC, the following standard system library functions are redefined with the #define mechanism to call corresponding functions within smartall.c instead. (For details of the redefinitions, please refer to smartall.h.)</p>
<pre><code>        void *malloc(size_t size)
        void *calloc(size_t nelem, size_t elsize)
        void *realloc(void *ptr, size_t size)
        void free(void *ptr)
        void cfree(void *ptr)</code></pre>
<p><span>cfree()</span> is a historical artifact identical to <span>free()</span>.</p>
<p>In addition to allocating storage in the same way as the standard library functions, the SMARTALLOC versions expand the buffers they allocate to include information that identifies where each buffer was allocated and to chain all allocated buffers together. When a buffer is released, it is removed from the allocated buffer chain. A call on <span>sm_dump()</span> is able, by scanning the chain of allocated buffers, to find all orphaned buffers. Buffers allocated while <span>sm_static(1)</span> is in effect are specially flagged so that, despite appearing on the allocated buffer chain, <span>sm_dump()</span> will not deem them orphans.</p>
<p>When a buffer is allocated by <span>malloc()</span> or expanded with <span>realloc()</span>, all bytes of newly allocated storage are set to the hexadecimal value 0x55 (alternating one and zero bits). Note that for <span>realloc()</span> this applies only to the bytes added at the end of buffer; the original contents of the buffer are not modified. Initializing allocated storage to a distinctive nonzero pattern is intended to catch code that erroneously assumes newly allocated buffers are cleared to zero; in fact their contents are random. The <span>calloc()</span> function, defined as returning a buffer cleared to zero, continues to zero its buffers under SMARTALLOC.</p>
<p>Buffers obtained with the SMARTALLOC functions contain a special sentinel byte at the end of the user data area. This byte is set to a special key value based upon the buffer’s memory address. When the buffer is released, the key is tested and if it has been overwritten an assertion in the <span>free</span> function will fail. This catches incorrect program code that stores beyond the storage allocated for the buffer. At <span>free()</span> time the queue links are also validated and an assertion failure will occur if the program has destroyed them by storing before the start of the allocated storage.</p>
<p>In addition, when a buffer is released with <span>free()</span>, its contents are immediately destroyed by overwriting them with the hexadecimal pattern 0xAA (alternating bits, the one’s complement of the initial value pattern). This will usually trip up code that keeps a pointer to a buffer that’s been freed and later attempts to reference data within the released buffer. Incredibly, this is <span><em>legal</em></span> in the standard Unix memory allocation package, which permits programs to free() buffers, then raise them from the grave with <span>realloc()</span>. Such program “logic” should be fixed, not accommodated, and SMARTALLOC brooks no such Lazarus buffer`` nonsense.</p>
<p>Some C libraries allow a zero size argument in calls to <span>malloc()</span>. Since this is far more likely to indicate a program error than a defensible programming stratagem, SMARTALLOC disallows it with an assertion.</p>
<p>When the standard library <span>realloc()</span> function is called to expand a buffer, it attempts to expand the buffer in place if possible, moving it only if necessary. Because SMARTALLOC must place its own private storage in the buffer and also to aid in error detection, its version of <span>realloc()</span> always moves and copies the buffer except in the trivial case where the size of the buffer is not being changed. By forcing the buffer to move on every call and destroying the contents of the old buffer when it is released, SMARTALLOC traps programs which keep pointers into a buffer across a call on <span>realloc()</span> which may move it. This strategy may prove very costly to programs which make extensive use of <span>realloc()</span>. If this proves to be a problem, such programs may wish to use <span>actuallymalloc()</span>, <span>actuallyrealloc()</span>, and <span>actuallyfree()</span> for such frequently-adjusted buffers, trading error detection for performance. Although not specified in the System V Interface Definition, many C library implementations of <span>realloc()</span> permit an old buffer argument of NULL, causing <span>realloc()</span> to allocate a new buffer. The SMARTALLOC version permits this.</p>
<h3 id="when-smartalloc-is-disabled">When SMARTALLOC is Disabled</h3>
<p>When SMARTALLOC is disabled by compiling a program with the symbol SMARTALLOC not defined, calls on the functions otherwise redefined by SMARTALLOC go directly to the system functions. In addition, compile-time definitions translate calls on the ”<span>actually</span>…<span>()</span>“ functions into the corresponding library calls; ”<span>actuallymalloc(100)</span>“, for example, compiles into”<span>malloc(100)</span>``. The two special SMARTALLOC functions, <span>sm_dump()</span> and <span>sm_static()</span>, are defined to generate no code (hence the null statement). Finally, if SMARTALLOC is not defined, compilation of the file smartall.c generates no code or data at all, effectively removing it from the program even if named in the link instructions.</p>
<p>Thus, except for unusual circumstances, a program that works with SMARTALLOC defined for testing should require no changes when built without it for production release.</p>
<h3 id="the-alloc-function">The <span>alloc()</span> Function</h3>
<p>Many programs I’ve worked on use very few direct calls to <span>malloc()</span>, using the identically declared <span>alloc()</span> function instead. Alloc detects out-of-memory conditions and aborts, removing the need for error checking on every call of <span>malloc()</span> (and the temptation to skip checking for out-of-memory).</p>
<p>As a convenience, SMARTALLOC supplies a compatible version of <span>alloc()</span> in the file alloc.c, with its definition in the file alloc.h. This version of <span>alloc()</span> is sensitive to the definition of SMARTALLOC and cooperates with SMARTALLOC’s orphaned buffer detection. In addition, when SMARTALLOC is defined and <span>alloc()</span> detects an out of memory condition, it takes advantage of the SMARTALLOC diagnostic information to identify the file and line number of the call on <span>alloc()</span> that failed.</p>
<h3 id="overlays-and-underhandedness">Overlays and Underhandedness</h3>
<p>String constants in the C language are considered to be static arrays of characters accessed through a pointer constant. The arrays are potentially writable even though their pointer is a constant. SMARTALLOC uses the compile-time definition <span>./smartall.wml</span> to obtain the name of the file in which a call on buffer allocation was performed. Rather than reserve space in a buffer to save this information, SMARTALLOC simply stores the pointer to the compiled-in text of the file name. This works fine as long as the program does not overlay its data among modules. If data are overlayed, the area of memory which contained the file name at the time it was saved in the buffer may contain something else entirely when <span>sm_dump()</span> gets around to using the pointer to edit the file name which allocated the buffer.</p>
<p>If you want to use SMARTALLOC in a program with overlayed data, you’ll have to modify smartall.c to either copy the file name to a fixed-length field added to the <span>abufhead</span> structure, or else allocate storage with <span>malloc()</span>, copy the file name there, and set the <span>abfname</span> pointer to that buffer, then remember to release the buffer in <span>sm_free</span>. Either of these approaches are wasteful of storage and time, and should be considered only if there is no alternative. Since most initial debugging is done in non-overlayed environments, the restrictions on SMARTALLOC with data overlaying may never prove a problem. Note that conventional overlaying of code, by far the most common form of overlaying, poses no problems for SMARTALLOC; you need only be concerned if you’re using exotic tools for data overlaying on MS-DOS or other address-space-challenged systems.</p>
<p>Since a C language ”constant`` string can actually be written into, most C compilers generate a unique copy of each string used in a module, even if the same constant string appears many times. In modules that contain many calls on allocation functions, this results in substantial wasted storage for the strings that identify the file name. If your compiler permits optimization of multiple occurrences of constant strings, enabling this mode will eliminate the overhead for these strings. Of course, it’s up to you to make sure choosing this compiler mode won’t wreak havoc on some other part of your program.</p>
<h3 id="test-and-demonstration-program">Test and Demonstration Program</h3>
<p>A test and demonstration program, smtest.c, is supplied with SMARTALLOC. You can build this program with the Makefile included. Please refer to the comments in smtest.c and the Makefile for information on this program. If you’re attempting to use SMARTALLOC on a new machine or with a new compiler or operating system, it’s a wise first step to check it out with smtest first.</p>
<h3 id="invitation-to-the-hack">Invitation to the Hack</h3>
<p>SMARTALLOC is not intended to be a panacea for storage management problems, nor is it universally applicable or effective; it’s another weapon in the arsenal of the defensive professional programmer attempting to create reliable products. It represents the current state of evolution of expedient debug code which has been used in several commercial software products which have, collectively, sold more than third of a million copies in the retail market, and can be expected to continue to develop through time as it is applied to ever more demanding projects.</p>
<p>The version of SMARTALLOC here has been tested on a Sun SPARCStation, Silicon Graphics Indigo2, and on MS-DOS using both Borland and Microsoft C. Moving from compiler to compiler requires the usual small changes to resolve disputes about prototyping of functions, whether the type returned by buffer allocation is <span>char </span> or <span>void </span>, and so forth, but following those changes it works in a variety of environments. I hope you’ll find SMARTALLOC as useful for your projects as I’ve found it in mine.</p>
<h2 id="zipped-archive-1">(Zipped archive)</h2>
<p>SMARTALLOC is provided as , a archive containing source code, documentation, and a <span>Makefile</span> to build the software under Unix.</p>
<h3 id="copying-1">Copying</h3>
<blockquote>
<p>SMARTALLOC is in the public domain. Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, without any conditions or restrictions. This software is provided ”as is`` without express or implied warranty.</p>
</blockquote>
<p><span>* October 30th, 1998 *</span></p>
<h1 id="gnu-free-documentation-license">GNU Free Documentation License</h1>
<p>Version 1.2, November 2002</p>
<p>Copyright ©2000,2001,2002 Free Software Foundation, Inc.</p>
<p>51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</p>
<p>Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.</p>
<p><span><strong>Preamble</strong></span></p>
<p>The purpose of this License is to make a manual, textbook, or other functional and useful document “free” in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others.</p>
<p>This License is a kind of “copyleft”, which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software.</p>
<p>We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference.</p>
<p><span><strong>1. APPLICABILITY AND DEFINITIONS</strong></span></p>
<p>This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The <strong>“Document”</strong>, below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as <strong>“you”</strong>. You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law.</p>
<p>A <strong>“Modified Version”</strong> of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language.</p>
<p>A <strong>“Secondary Section”</strong> is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document’s overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them.</p>
<p>The <strong>“Invariant Sections”</strong> are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none.</p>
<p>The <strong>“Cover Texts”</strong> are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words.</p>
<p>A <strong>“Transparent”</strong> copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not “Transparent” is called <strong>“Opaque”</strong>.</p>
<p>Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly available DTD, and standard-conforming simple HTML, PostScript or PDF designed for human modification. Examples of transparent image formats include PNG, XCF and JPG. Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and the machine-generated HTML, PostScript or PDF produced by some word processors for output purposes only.</p>
<p>The <strong>“Title Page”</strong> means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, “Title Page” means the text near the most prominent appearance of the work’s title, preceding the beginning of the body of the text.</p>
<p>A section <strong>“Entitled XYZ”</strong> means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language. (Here XYZ stands for a specific section name mentioned below, such as <strong>“Acknowledgements”</strong>, <strong>“Dedications”</strong>, <strong>“Endorsements”</strong>, or <strong>“History”</strong>.) To <strong>“Preserve the Title”</strong> of such a section when you modify the Document means that it remains a section “Entitled XYZ” according to this definition.</p>
<p>The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.</p>
<p><span><strong>2. VERBATIM COPYING</strong></span></p>
<p>You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3.</p>
<p>You may also lend copies, under the same conditions stated above, and you may publicly display copies.</p>
<p><span><strong>3. COPYING IN QUANTITY</strong></span></p>
<p>If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document’s license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects.</p>
<p>If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages.</p>
<p>If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public.</p>
<p>It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.</p>
<p><span><strong>4. MODIFICATIONS</strong></span></p>
<p>You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:</p>
<ul>
<li><p>Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission.</p></li>
<li><p>List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement.</p></li>
<li><p>State on the Title page the name of the publisher of the Modified Version, as the publisher.</p></li>
<li><p>Preserve all the copyright notices of the Document.</p></li>
<li><p>Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.</p></li>
<li><p>Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below.</p></li>
<li><p>Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document’s license notice.</p></li>
<li><p>Include an unaltered copy of this License.</p></li>
<li><p>Preserve the section Entitled “History”, Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page. If there is no section Entitled “History” in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence.</p></li>
<li><p>Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the “History” section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission.</p></li>
<li><p>For any section Entitled “Acknowledgements” or “Dedications”, Preserve the Title of the section, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein.</p></li>
<li><p>Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section numbers or the equivalent are not considered part of the section titles.</p></li>
<li><p>Delete any section Entitled “Endorsements”. Such a section may not be included in the Modified Version.</p></li>
<li><p>Do not retitle any existing section to be Entitled “Endorsements” or to conflict in title with any Invariant Section.</p></li>
<li><p>Preserve any Warranty Disclaimers.</p></li>
</ul>
<p>If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version’s license notice. These titles must be distinct from any other section titles.</p>
<p>You may add a section Entitled “Endorsements”, provided it contains nothing but endorsements of your Modified Version by various parties–for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard.</p>
<p>You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one.</p>
<p>The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.</p>
<p><span><strong>5. COMBINING DOCUMENTS</strong></span></p>
<p>You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers.</p>
<p>The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work.</p>
<p>In the combination, you must combine any sections Entitled “History” in the various original documents, forming one section Entitled “History”; likewise combine any sections Entitled “Acknowledgements”, and any sections Entitled “Dedications”. You must delete all sections Entitled “Endorsements”.</p>
<p><span><strong>6. COLLECTIONS OF DOCUMENTS</strong></span></p>
<p>You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects.</p>
<p>You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.</p>
<p><span><strong>7. AGGREGATION WITH INDEPENDENT WORKS</strong></span></p>
<p>A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an “aggregate” if the copyright resulting from the compilation is not used to limit the legal rights of the compilation’s users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document.</p>
<p>If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document’s Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.</p>
<p><span><strong>8. TRANSLATION</strong></span></p>
<p>Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail.</p>
<p>If a section in the Document is Entitled “Acknowledgements”, “Dedications”, or “History”, the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.</p>
<p><span><strong>9. TERMINATION</strong></span></p>
<p>You may not copy, modify, sublicense, or distribute the Document except as expressly provided for under this License. Any other attempt to copy, modify, sublicense or distribute the Document is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance.</p>
<p><span><strong>10. FUTURE REVISIONS OF THIS LICENSE</strong></span></p>
<p>The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See http://www.gnu.org/copyleft/.</p>
<p>Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License “or any later version” applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation.</p>
<p><span><strong>ADDENDUM: How to use this License for your documents</strong></span></p>
<p>To use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page:</p>
<blockquote>
<p>Copyright ©YEAR YOUR NAME. Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled “GNU Free Documentation License”.</p>
</blockquote>
<p>If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the “with…Texts.” line with this:</p>
<blockquote>
<p>with the Invariant Sections being LIST THEIR TITLES, with the Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.</p>
</blockquote>
<p>If you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation.</p>
<p>If your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software.</p>
<div id="footer">
<hr>
&copy; 2015 <a href="http://www.bareos.org/">Bareos Project</a>
<hr>
</div>
</body>
</html>
